<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[毕业设计公开进度网站]]></title>
  <link href="https://zning.me/GD/atom.xml" rel="self"/>
  <link href="https://zning.me/GD/"/>
  <updated>2016-12-27T13:18:41+08:00</updated>
  <id>https://zning.me/GD/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[阿里云Ubuntu 14.04 Spark单机环境搭建与初步学习]]></title>
    <link href="https://zning.me/GD/14828004915608.html"/>
    <updated>2016-12-27T09:01:31+08:00</updated>
    <id>https://zning.me/GD/14828004915608.html</id>
    <content type="html"><![CDATA[
<p>最近课设需要学习，预先学习了一波。</p>

<blockquote>
<p>注意：本文首次撰写于2016-12-27，最近修改时间为2016-12-27，请注意相关程序的可用性与安全性。</p>
</blockquote>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">安装与配置</a>
<ul>
<li>
<a href="#toc_1">安装Java</a>
</li>
<li>
<a href="#toc_2">安装Scala</a>
</li>
<li>
<a href="#toc_3">安装Spark</a>
</li>
<li>
<a href="#toc_4">安装sbt</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">初识Spark</a>
<ul>
<li>
<a href="#toc_6">Spark 终端</a>
</li>
<li>
<a href="#toc_7">Spark 例子：回归模型</a>
</li>
<li>
<a href="#toc_8">整体印象</a>
</li>
<li>
<a href="#toc_9">学习资源</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">参考资料与文献</a>
</li>
</ul>


<h2 id="toc_0">安装与配置</h2>

<p>大数据这个领域是热火朝天，而<a href="http://spark.apache.org/">Apache Spark</a>则是一个炙手可热大数据神器。趁着现在还比较有空，赶紧学习Spark方面的东西。</p>

<p>这一小节主要是记录下在Ubuntu 14.04下搭建Spark单机环境的过程<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>。这个过程主要有四个部分：</p>

<ul>
<li>安装Java</li>
<li>安装Scala</li>
<li>安装Spark</li>
<li>安装sbt</li>
</ul>

<h3 id="toc_1">安装Java</h3>

<ul>
<li><p>下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java SE</a>，然后解压</p>

<pre><code># wget http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.tar.gz?AuthParam=1482801228_c2a115fb9b0cbc9f160e02b5c29212c7
# mv jdk-8u112-linux-x64.tar.gz\?AuthParam\=1482801228_c2a115fb9b0cbc9f160e02b5c29212c7 jdk-8u112-linux-x64.tar.gz
# tar -zxvf jdk-8u112-linux-x64.tar.gz -C /opt/
</code></pre>

<blockquote>
<p>这里需要解释下为什么这么做：因为我直接从Java官网上下载的，而官网下载之前需要确认协议，如果直接复制官网下载地址则会出现下载的是个网页的情况。所以只能通过一个带有AuthParam序号的下载地址下载后再修改文件名了。如果有更好的方法的朋友，请联系我告知。谢谢！2016-12-27 12:05:05</p>
</blockquote></li>
<li><p>配置环境变量</p>

<p>Ubuntu的环境变量又好几个地方可以配置，我这里配置的是<code>/etc/profile</code>文件。</p>

<pre><code>export JAVA_HOME=/opt/jdk1.8.0_112
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin:$PATH
</code></pre></li>
<li><p>之后重启服务器，或者输入<code>source /etc/profile</code>命令，使环境变量生效，检验Java有没配置成功</p>

<pre><code>$ java -version
java version &quot;1.8.0_60&quot;
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)
$ javac -version
javac 1.8.0_60
</code></pre></li>
</ul>

<h3 id="toc_2">安装Scala</h3>

<p>Scala安装过程和Java的类似，比较简单</p>

<ul>
<li><p><a href="http://www.scala-lang.org/download/">官网</a>下载压缩包，然后解压</p>

<pre><code># mkdir /opt/scala
# wget http://downloads.lightbend.com/scala/2.12.1/scala-2.12.1.tgz
# tar -zxvf scala-2.12.1.tgz -C /opt/scala/
</code></pre></li>
<li><p>配置环境变量 <code>/etc/profile</code></p>

<pre><code>export SCALA_HOME=/opt/scala/scala-2.12.1
export PATH=${SCALA_HOME}/bin:$PATH
</code></pre></li>
<li><p>重启服务器，或者输入<code>source /etc/profile</code>命令，使环境变量生效，测试一下</p>

<pre><code># scala -version
Scala code runner version 2.11.7 -- Copyright 2002-2013, LAMP/EPFL
</code></pre></li>
</ul>

<h3 id="toc_3">安装Spark</h3>

<ul>
<li><p><a href="http://spark.apache.org/">官网</a>下载压缩文件。这里我选择的是2.0.2版本的Pre-build for Hadoop2.7 and later. 解压</p>

<pre><code># mkdir /opt/spark
# wget http://download.nextag.com/apache/spark/spark-2.0.2/spark-2.0.2-bin-hadoop2.7.tgz
# tar -zxvf spark-2.0.2-bin-hadoop2.7.tgz -C /opt/spark/
</code></pre></li>
<li><p>配置环境变量 /etc/profile</p>

<pre><code>export SPARK_HOME=/opt/spark/spark-2.0.2-bin-hadoop2.7
export PATH=${SPARK_HOME}/bin:$PATH
</code></pre>

<p>重启服务器，或者输入<code>source /etc/profile</code>命令，使环境变量生效。</p>

<p>到这里，应该就可以启动spark-shell，跟着Spark官网上的教程来学API了。</p></li>
</ul>

<h3 id="toc_4">安装sbt</h3>

<p>安装sbt我参考的是这篇文章<a href="http://www.cnblogs.com/wrencai/p/3867898.html">ubuntu14手动安装sbt</a></p>

<ul>
<li><p><a href="http://www.scala-sbt.org/">官网</a>下载解压</p>

<pre><code># mkdir /opt/scala/
# wget https://dl.bintray.com/sbt/native-packages/sbt/0.13.13/sbt-0.13.13.tgz
# tar -zxvf sbt-0.13.13.tgz -C /opt/scala/
# cd /opt/scala/
# mv sbt-launcher-packaging-0.13.13 sbt
</code></pre></li>
<li><p>配置环境变量 <code>/etc/profile</code></p>

<pre><code>export SBT_HOME=/opt/scala/sbt
export PATH=${SBT_HOME}/bin:$PATH
</code></pre></li>
<li><p>建立启动sbt的脚本</p>

<pre><code># mkdir /opt/scala/sbt/
# cd /opt/scala/sbt/
# touch sbt

# 脚本内容如下，注意sbt-launch.jar的路径
SBT_OPTS=&quot;-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M&quot;
java $SBT_OPTS -jar /opt/scala/sbt/bin/sbt-launch.jar &quot;$@&quot;
</code></pre></li>
<li><p>修改sbt文件权限</p>

<pre><code># chmod u+x sbt
</code></pre></li>
<li><p>测试sbt</p>

<pre><code># sbt sbt-version
Getting org.scala-sbt sbt 0.13.13 ...
[info] Set current project to kaka (in build file:/home/kaka/)
[info] 0.13.13
</code></pre>

<p>第一次执行的时候会下载很多东西，然后因为国内你猜到的原因，这一步会比较慢，也很有可能会失败。可以通过如下步骤设置国内的sbt源 <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>：</p>

<pre><code>#vim ~/.sbt/repositories
</code></pre>

<p>在里面输入如下内容：</p>

<pre><code>[repositories]
  local
  oschina:http://maven.oschina.net/content/groups/public/
  oschina-ivy:http://maven.oschina.net/content/groups/public/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]
</code></pre>

<blockquote>
<p>不过这个并没有成功，目前来看还是因为你懂得的原因，正在寻找解决方案。2016-12-27 12:34:43</p>
</blockquote>

<p>到此为止，Spark的单机环境就搭建完毕，下一步就是认真地学习Spark了。</p></li>
</ul>

<h2 id="toc_5">初识Spark</h2>

<p>这一小节主要介绍下Spark相关语法与操作指南。<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup></p>

<h3 id="toc_6">Spark 终端</h3>

<p>我觉得 Spark 非常亲民的一点是它提供了一个交互式的命令行终端，这样用户就可以快速地测试一些命令和语句，而无需每次都保存代码脚本然后调用执行，这对于 R 和 Python 用户来说是非常顺心的一件事。如果已经将 Spark 的 <code>bin</code> 目录加入到了系统路径，那么在系统命令行里输入 <code>spark-shell</code> 就可以进入 Spark 的交互式终端了。</p>

<p><img src="media/14828004915608/14828138714552.jpg" alt=""/></p>

<p>如果出现了像图中 <code>scala&gt;</code> 这样的提示符，就说明 Spark 安装成功。这里的 <code>scala</code> 指的是 Scala 编程语言。前面说了，Spark 主要使用 Scala 来进行开发，这意味着要最大程度地发挥 Spark 的性能，还需要再多学一门编程语言（Spark 还支持 Java 和 Python 的接口，但 Java 的语法没有 Scala 简洁，Python 的性能没有 Scala 的高）。虽然这需要花费一些额外的时间，但好在 Scala 的语法非常直观，基本上通过例子就可以模仿写出自己的程序来。</p>

<p>如果对 Scala 语言感兴趣，可以参考<a href="http://people.cis.ksu.edu/%7Eschmidt/705a/Scala/scala_tutorial.pdf">这份教程</a>来了解其基本的语法。但在这里我们将直接进入正题，用 Spark 来跑一个回归的例子。</p>

<h3 id="toc_7">Spark 例子：回归模型</h3>

<p>Spark 的数据分析功能包含在一个称为 MLlib 的组件当中，顾名思义，这是 Spark 的机器学习库，而回归是它支持的模型之一。为了演示例子，我们首先用 R 生成一组模拟的数据（是不是感觉怪怪的，主要是我还没用熟 Scala）：</p>

<pre><code>set.seed(123)
n = 1e6
p = 5
x = matrix(rnorm(n * p), n)
b = rnorm(p)
y = x %*% b + rnorm(n, 1, 3)
z = data.frame(y, x)
write.table(z, &quot;reg.txt&quot;, sep = &quot; &quot;, row.names = FALSE, col.names = FALSE)

</code></pre>

<p>我们将数据保存为 <code>reg.txt</code> 文件，它共有一百万行，每一行有6个数，用空格分隔，其中第一个数代表因变量，其余的为自变量。</p>

<p>下面就是一段用 Scala 实现的 Spark 算回归的程序，其中包括了读取数据，拟合回归，计算回归系数，进行模型预测以及计算 R2R2 的过程。将这段程序复制到 Spark 的终端里，就可以迅速查看输出结果，体验 Spark 的基本功能了。</p>

<pre><code>import org.apache.spark.mllib.linalg.Vectors
import org.apache.spark.mllib.regression.LabeledPoint
import org.apache.spark.mllib.regression.LinearRegressionWithSGD
import org.apache.spark.mllib.stat.Statistics

val raw = sc.textFile(&quot;reg.txt&quot;)

val parsed = raw.map({ line =&gt;
    val split = line.split(&#39; &#39;) // 字符串按空格切分
    val y = split(0).toDouble   // 第一个数转成Double型，是因变量
    val x = split.tail.map(_.toDouble) // 其余的转成自变量向量
    LabeledPoint(y, Vectors.dense(x))  // 把因变量和自变量打包
}).cache()

println(parsed.count())

val model = new LinearRegressionWithSGD()

model.optimizer.setNumIterations(100)
model.setIntercept(true)

val tstart = System.currentTimeMillis()
val res = model.run(parsed)
val tend = System.currentTimeMillis()

println(&quot;Model training time: &quot; + (tend - tstart) / 1000.0 + &quot; secs&quot;)

println(res.intercept)
println(res.weights)

val pred = res.predict(parsed.map(_.features))

val r = Statistics.corr(pred, parsed.map(_.label))
println(&quot;R-square = &quot; + r * r)

</code></pre>

<p>下面我们来解释一下程序中每一部分的含义。开头1到4行的是一系列的 <code>import</code> 语句，目的是使用一些已经封装好的类，与 R 中的 <code>library()</code> 和 Python 的 <code>import</code> 语句类似。另外，相信不少读者立刻就能看出这是 Java 风格的导入语句。事实上，Scala 正是基于 Java 而开发的，因此其语法也大多脱胎于 Java。</p>

<p>第6行是读取数据，并将结果赋值给一个变量 <code>raw</code>。特别需要指出的是，这条语句实际上并没有开始读取文件，而只是建立了数据与程序之间的一种连接。这一点是与 R 中 <code>read.table()</code> 最大的不同。</p>

<p>第8到第13行其实包含了两条操作，第一是调用了 <code>raw</code> 对象的 <code>map()</code> 方法，之后连着的是 <code>cache()</code>方法。<code>map()</code> 相当于 R 中的 <code>apply()</code>，意思是对读进来文件的每一行进行一次变换，然后将结果返回，组成一个新的向量。之所以需要这么做，是因为 Spark 读取文本文件时把每一行当作了一个字符串，因此我们需要从这个字符串中解析出我们需要的数据来。语句中被大括号包括的部分其实就是定义了这样一个变换函数，其输入是参数 <code>line</code>，代表传入函数的那个字符串，而输出是一个 <code>LabeledPoint</code> 对象，它是 MLlib 中定义的一个数据结构，用来代表一个因变量-自变量的配对观测。<code>map()</code> 方法返回的结果，就是一个长度为一百万，每个元素为 <code>LabeledPoint</code> 类型的向量。</p>

<p>接下来的 <code>cache()</code> 方法是 Spark 非常独到的一个操作，它是为了告诉 Spark，只要内存足够（限额可以通过 Spark 中的配置文件设置），就将数据放到内存里，以加快后续程序的运算速度。如果内存放不下，就依然保存到硬盘中。这样的好处在于，一方面避免了 R 把所有对象都往内存放的操作，另一方面避免了 Hadoop 这种重度依赖硬盘，以至于效率低下的情形。</p>

<p>而有趣的是，执行完这一句后，数据其实还没有进行真正的读取。这是因为 Spark 采用了一种“延迟运行”的机制，意思是数据只有在真正用到的地方才开始运算，其理念就是，“<strong>只要老师不检查作业，我就暂时不写</strong>”。基于这个原因，数据只有到了下面 <code>parsed.count()</code> 这句需要计算样本量时才真正开始进行读取和变换。</p>

<p>接下来的第17到26行就是真正拟合回归模型的时候了。MLlib 里拟合回归采用的是随机梯度下降法（SGD），选用这种算法的原因，一是因为它是一种迭代算法，可以通过设置迭代次数来随时终止计算（当然同时会损失一部分精度），这对于大规模的数据是非常关键的，因为通常在这些场合下我们不要求结果非常精确，但却希望计算能在规定的时间里完成。而另一个原因就在于这种算法可以比较容易地进行并行，扩展性较好。</p>

<p>第17行中，我们先建立模型对象，然后在19、20行设置最大迭代次数以及告诉模型应该包括截距项。22和24行插入了两句获取时间的函数，是为了评估模型训练（23行）花费的时间。</p>

<p>在第31行中，我们用拟合出的模型对训练集本身进行了预测。<code>parsed.map(_.features)</code> 的目的是取出训练集中的自变量部分，而 <code>predict()</code> 方法返回的结果就是因变量的预测值向量。</p>

<p>最后的第33行，我们利用 MLlib 为我们封装好的 <code>corr()</code> 函数计算了预测值与真实值之间的相关系数（<code>parsed.map(_.label)</code> 与 <code>parsed.map(_.features)</code> 相对，是取出训练集中的因变量），将它平方一下，就是模型的 R2R2 值了。</p>

<!--

### 整体印象

总体感觉，Spark 还是挺好上手的，唯一麻烦的地方大概就是要对 Scala 语言有所了解。不过好在 Spark 也提供了 Python 和 Java 的接口，所以如果只是想尝尝鲜，也完全可以用其他的语言来加以操作。另外一个好消息是，从2015年4月起，Spark 官方已经开始提供 R 语言的接口，大约在2015年夏季发布 Spark 1.4 版本时，R 用户就可以使用原生的 Spark 接口了。

-->

<h3 id="toc_8">学习资源</h3>

<p>下面几个链接我觉得对于 Spark 入门是非常有帮助的：</p>

<ol>
<li><a href="http://ampcamp.berkeley.edu/big-data-mini-course/index.html">伯克利的 Spark 迷你课程</a></li>
<li><a href="https://spark.apache.org/docs/latest/quick-start.html">Spark 官方快速入门教程</a></li>
<li><a href="https://spark.apache.org/docs/latest/mllib-guide.html">MLlib 官方文档</a></li>
</ol>

<h2 id="toc_9">参考资料与文献</h2>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>曾梦想仗剑走天涯. <a href="http://kwangka.github.io/2015/10/15/installspark/">Ubuntu 14.04 Spark单机环境搭建</a>[EB/OL]. <a href="http://kwangka.github.io/2015/10/15/installspark/">http://kwangka.github.io/2015/10/15/installspark/</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>SegmentFault. <a href="http://segmentfault.com/a/1190000002474507">加速SBT下载依赖库的速度</a>[EB/OL]. <a href="http://segmentfault.com/a/1190000002474507">http://segmentfault.com/a/1190000002474507</a>.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>sbt. <a href="http://www.scala-sbt.org/0.13/docs/Proxy-Repositories.html">Proxy Repositories</a>[EB/OL]. <a href="http://www.scala-sbt.org/0.13/docs/Proxy-Repositories.html">http://www.scala-sbt.org/0.13/docs/Proxy-Repositories.html</a>.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>怡然轩. <a href="http://yixuan.cos.name/cn/2015/04/spark-beginner-1/">极简 Spark 入门笔记——安装和第一个回归程序</a>[EB/OL]. <a href="http://yixuan.cos.name/cn/2015/04/spark-beginner-1/">http://yixuan.cos.name/cn/2015/04/spark-beginner-1/</a>.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[真实的毕业设计思路]]></title>
    <link href="https://zning.me/GD/14828101562831.html"/>
    <updated>2016-12-27T11:42:36+08:00</updated>
    <id>https://zning.me/GD/14828101562831.html</id>
    <content type="html"><![CDATA[
<p>其实刚才那个是开玩笑的……这个才是老师给布置的毕业设计思路……</p>

<blockquote>
<p>未完待续</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人设想的毕业设计思路]]></title>
    <link href="https://zning.me/GD/14668306559344.html"/>
    <updated>2016-06-25T12:57:35+08:00</updated>
    <id>https://zning.me/GD/14668306559344.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">题目</h3>

<p>基于聚类挖掘分析的心率检测与其在健康领域的应用</p>

<h3 id="toc_1">设想</h3>

<p>心率监测形成的数据进行数据分析，通过数据积累形成一定数据量后，通过经验分析与医疗经验，对心率变化情况作出预测接下来一段时间人体是否健康并提出预警提示。</p>

<h3 id="toc_2">实现成果</h3>

<ol>
<li>基于聚类挖掘分析的心率数据分析算法</li>
<li>心率数据采集系统（硬件+传输中介设备+信息采集与存储开放平台）</li>
<li>心率数据分析系统（对形成的数据）</li>
</ol>

<h3 id="toc_3">关键点与难点</h3>

<h4 id="toc_4">关键点</h4>

<ol>
<li>心率与相关疾病的联系（需要医学支持）</li>
<li>心率数据分析算法的设计（分析当前心率下的人体状态与健康状态，并通过历史数据的挖掘结果提供合适的预测值）</li>
<li>心率数据的存储（实时数据存储的数据结构、数据库结构的研究）</li>
<li>心率数据的传输（通过硬件传输给用户手机中开发的APP，或者在家里的专用配套设备等，再通过互联网传输到心率数据采集系统进行存储）</li>
<li>心率数据的获取（通过传感器进行采集）</li>
<li>本设计展示给用户的客户端设计（Android、iOS端在Web+Native下的混合开发，以及PC端平台的客户端设计）</li>
</ol>

<h4 id="toc_5">难点</h4>

<ol>
<li>如何对数据进行分析？如何聚类？</li>
<li>聚类方法有哪些？</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Web]北京交大925数据结构复习笔记]]></title>
    <link href="https://zning.me/GD/14783502760965.html"/>
    <updated>2016-11-05T20:51:16+08:00</updated>
    <id>https://zning.me/GD/14783502760965.html</id>
    <content type="html"><![CDATA[
<p><strong>——By ZNing</strong></p>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">2017数据结构考试大纲</a>
<ul>
<li>
<a href="#toc_1">1、绪论</a>
</li>
<li>
<a href="#toc_2">2、线性表</a>
</li>
<li>
<a href="#toc_3">3、栈和队列</a>
</li>
<li>
<a href="#toc_4">4、串</a>
</li>
<li>
<a href="#toc_5">5、数组和广义表</a>
</li>
<li>
<a href="#toc_6">6、树和二叉树</a>
</li>
<li>
<a href="#toc_7">7、图</a>
</li>
<li>
<a href="#toc_8">8、查找</a>
</li>
<li>
<a href="#toc_9">9、排序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">第一章 绪论</a>
<ul>
<li>
<a href="#toc_11">一、考纲要求</a>
</li>
<li>
<a href="#toc_12">二、基本知识</a>
<ul>
<li>
<a href="#toc_13">1. 数据元素是数据的基本单位</a>
</li>
<li>
<a href="#toc_14">2. 数据项是数据不可分割的最小单位</a>
</li>
<li>
<a href="#toc_15">3. 数据结构及其形式定义</a>
</li>
<li>
<a href="#toc_16">4. 关于逻辑结构域存储结构的关系及存储结构的分类的几个定义</a>
</li>
<li>
<a href="#toc_17">5. 数据类型与抽象数据类型</a>
</li>
<li>
<a href="#toc_18">6. 算法的概念</a>
</li>
<li>
<a href="#toc_19">7. 算法的五个特性</a>
</li>
<li>
<a href="#toc_20">8. 算法的设计要求</a>
</li>
<li>
<a href="#toc_21">9. 算法的时间复杂度</a>
</li>
<li>
<a href="#toc_22">10. 算法的空间复杂度（一般不作要求）</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_23">第二章 线性表</a>
<ul>
<li>
<a href="#toc_24">一、考纲要求</a>
</li>
<li>
<a href="#toc_25">二、基本知识</a>
<ul>
<li>
<a href="#toc_26">1. 线性表及其特点</a>
</li>
<li>
<a href="#toc_27">2. 顺序表——线性表的顺序存储结构</a>
</li>
<li>
<a href="#toc_28">3. 单链表——线性表的链式存储结构之一</a>
</li>
<li>
<a href="#toc_29">4. 循环链表</a>
</li>
<li>
<a href="#toc_30">5. 双向循环链表</a>
</li>
<li>
<a href="#toc_31">6. 顺序表与单链表的比较</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_32">第三章 栈和队列</a>
<ul>
<li>
<a href="#toc_33">一、考纲要求</a>
</li>
<li>
<a href="#toc_34">二、基本知识</a>
<ul>
<li>
<a href="#toc_35">1. 栈</a>
</li>
<li>
<a href="#toc_36">2. 链栈</a>
</li>
<li>
<a href="#toc_37">3. 顺序栈</a>
</li>
<li>
<a href="#toc_38">4. 队列</a>
</li>
<li>
<a href="#toc_39">5. 链队列</a>
</li>
<li>
<a href="#toc_40">6. 循环队列</a>
</li>
<li>
<a href="#toc_41">7. 栈和队列比较</a>
</li>
<li>
<a href="#toc_42">8. 简化的栈和队列结构</a>
</li>
<li>
<a href="#toc_43">9. 栈和队列的应用</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_44">第四章 串</a>
<ul>
<li>
<a href="#toc_45">一、考纲要求</a>
</li>
<li>
<a href="#toc_46">二、基本知识</a>
<ul>
<li>
<a href="#toc_47">1. 概念</a>
</li>
<li>
<a href="#toc_48">1. 串的基本操作</a>
</li>
<li>
<a href="#toc_49">1. 串的存储结构</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_50">第五章 数组和广义表</a>
<ul>
<li>
<a href="#toc_51">一、考纲要求</a>
</li>
<li>
<a href="#toc_52">二、基本知识</a>
<ul>
<li>
<a href="#toc_53">1. 数组的定义</a>
</li>
<li>
<a href="#toc_54">2. 数组的顺序存储</a>
</li>
<li>
<a href="#toc_55">3. 矩阵的压缩存储</a>
</li>
<li>
<a href="#toc_56">4. 广义表的定义</a>
</li>
<li>
<a href="#toc_57">5. 广义表的存储结构</a>
</li>
<li>
<a href="#toc_58">6. 总结</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_59">第六章 树和二叉树</a>
<ul>
<li>
<a href="#toc_60">一、考纲要求</a>
</li>
<li>
<a href="#toc_61">二、基本知识</a>
<ul>
<li>
<a href="#toc_62">1. 树及其有关概念</a>
</li>
<li>
<a href="#toc_63">2. 二叉树</a>
</li>
<li>
<a href="#toc_64">3. 二叉树的性质</a>
</li>
<li>
<a href="#toc_65">4. 二叉树的存储结构</a>
</li>
<li>
<a href="#toc_66">5. 二叉树的五种基本形态</a>
</li>
<li>
<a href="#toc_67">6. 遍历二叉树</a>
</li>
<li>
<a href="#toc_68">7. 遍历二叉树的应用</a>
</li>
<li>
<a href="#toc_69">8. 线索二叉树</a>
</li>
<li>
<a href="#toc_70">9. 树和森林</a>
</li>
<li>
<a href="#toc_71">10. 赫夫曼树及其应用</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_72">第七章 图</a>
<ul>
<li>
<a href="#toc_73">一、考纲要求</a>
</li>
<li>
<a href="#toc_74">二、基本知识</a>
<ul>
<li>
<a href="#toc_75">1. 图的有关概念</a>
</li>
<li>
<a href="#toc_76">2. 图的存储结构</a>
</li>
<li>
<a href="#toc_77">3. 图的遍历</a>
</li>
<li>
<a href="#toc_78">4. 最小生成树</a>
</li>
<li>
<a href="#toc_79">5. 拓扑排序</a>
</li>
<li>
<a href="#toc_80">6. 关键路径</a>
</li>
<li>
<a href="#toc_81">7. 最短路径</a>
</li>
<li>
<a href="#toc_82">8. 动态存储结构</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_83">第八章 查找</a>
<ul>
<li>
<a href="#toc_84">一、考纲要求</a>
</li>
<li>
<a href="#toc_85">二、基本知识</a>
<ul>
<li>
<a href="#toc_86">1. 查找的有关概念</a>
</li>
<li>
<a href="#toc_87">2. 顺序查找</a>
</li>
<li>
<a href="#toc_88">3. 折半查找</a>
</li>
<li>
<a href="#toc_89">4. 索引顺序表</a>
</li>
<li>
<a href="#toc_90">5. 二叉树排序</a>
</li>
<li>
<a href="#toc_91">6. 平衡二叉树</a>
</li>
<li>
<a href="#toc_92">7. B-树与B+树</a>
</li>
<li>
<a href="#toc_93">8. 键树</a>
</li>
<li>
<a href="#toc_94">9. 哈希表</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_95">第九章 排序</a>
<ul>
<li>
<a href="#toc_96">一、考纲要求</a>
</li>
<li>
<a href="#toc_97">二、基本知识</a>
<ul>
<li>
<a href="#toc_98">1. 排序的有关概念</a>
</li>
<li>
<a href="#toc_99">2. 直接插入排序</a>
</li>
<li>
<a href="#toc_100">3. 折半插入排序</a>
</li>
<li>
<a href="#toc_101">4. 希尔排序（缩小增量排序）</a>
</li>
<li>
<a href="#toc_102">5. 冒泡排序</a>
</li>
<li>
<a href="#toc_103">6. 快速排序</a>
</li>
<li>
<a href="#toc_104">7. 简单选择排序</a>
</li>
<li>
<a href="#toc_105">8. 堆排序</a>
</li>
<li>
<a href="#toc_106">9. 归并排序</a>
</li>
<li>
<a href="#toc_107">10. 基数排序</a>
</li>
<li>
<a href="#toc_108">11. 各种排序比较</a>
</li>
<li>
<a href="#toc_109">12. 外部排序</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">2017数据结构考试大纲</h2>

<h3 id="toc_1">1、绪论</h3>

<ol>
<li>掌握相关的基本概念，如数据结构、逻辑结构、存储结构、数据类型、抽象数据类型等；</li>
<li>掌握算法设计的原则，掌握计算语句频度和估算算法时间复杂度和空间复杂度的方法；</li>
<li>了解使用类C语言描述算法的方法。</li>
</ol>

<h3 id="toc_2">2、线性表</h3>

<ol>
<li>掌握线性表的逻辑结构和存储结构；</li>
<li>掌握线性表在顺序结构和链式结构上实现基本操作的方法；</li>
<li>理解线性表两种存储结构的不同特点及其适用场合，会针对需求选用合适的存储结构解决实际问题；</li>
<li>了解一元多项式的表示方法和基本运算的实现方法。</li>
</ol>

<h3 id="toc_3">3、栈和队列</h3>

<ol>
<li>了解栈和队列的特点；</li>
<li>掌握在两种存储结构上栈的基本操作的实现；</li>
<li>掌握栈的各种应用，理解递归算法执行过程中栈状态的变化过程；</li>
<li>掌握循环队列和链队列的基本运算；</li>
<li>会应用队列结构解决实际问题。</li>
</ol>

<h3 id="toc_4">4、串</h3>

<ol>
<li>掌握串的基本运算的定义，了解利用基本运算来实现串的其它运算的方法；</li>
<li>了解在顺序存储结构和在堆存储结构以及块链存储结构上实现串的各种操作的方法；</li>
<li>理解KMP算法，掌握NEXT函数和改进NEXT函数的定义和计算。</li>
</ol>

<h3 id="toc_5">5、数组和广义表</h3>

<ol>
<li>掌握数组在以行为主和以列为主的存储结构中的地址计算方法；</li>
<li>掌握矩阵压缩存储时的下标变换方法，了解以三元组表示稀疏矩阵的方法；</li>
<li>理解广义表的定义及其存储结构，理解广义表的头尾和子表两种分析方法。</li>
</ol>

<h3 id="toc_6">6、树和二叉树</h3>

<ol>
<li>熟练掌握二叉树的结构特点和性质，掌握二叉树各种存储结构及构建方法；</li>
<li>掌握按先序、中序、后序和层次次序遍历二叉树的算法，理解二叉树的线索化实质和方法；</li>
<li>利用二叉树的遍历求解实际问题；</li>
<li>掌握树的各种存储结构及其特点，掌握树的各种运算的实现算法；</li>
<li>掌握建立最优二叉树和哈夫曼编码的方法。</li>
</ol>

<h3 id="toc_7">7、图</h3>

<ol>
<li>熟练掌握图的基本概念，会构建各种图的存储结构；</li>
<li>掌握深度优先搜索遍历图和广度优先搜索遍历图的算法；</li>
<li>灵活运用图的遍历算法求解各种路径问题，包括最小生成树﹑最短路径﹑拓扑排序﹑关键路径等。</li>
</ol>

<h3 id="toc_8">8、查找</h3>

<ol>
<li>熟练掌握各种静态查找和动态查找算法，会计算查找成功时和失败时的平均查找长度；</li>
<li>掌握二叉排序树的建立、插入和删除过程，掌握二叉平衡树的建立和旋转平衡方法；</li>
<li>掌握B-树的建立、插入和删除结点的过程；</li>
<li>熟练掌握哈希表的构造方法和处理冲突的方法。</li>
</ol>

<h3 id="toc_9">9、排序</h3>

<ol>
<li>掌握各种排序算法，包括插入类、交换类、选择类、归并类排序及基数排序；</li>
<li>能够对各种排序方法进行比较分析，如稳定性、时间和空间性能等，了解各种排序方法的特点和不同并灵活应用；</li>
<li>理解外部排序的主要思想和过程。</li>
</ol>

<h2 id="toc_10">第一章 绪论</h2>

<h3 id="toc_11">一、考纲要求</h3>

<ol>
<li>掌握相关的基本概念，如数据结构、逻辑结构、存储结构、数据类型、抽象数据类型等；</li>
<li>掌握算法设计的原则，掌握计算语句频度和估算算法时间复杂度和空间复杂度的方法；</li>
<li>了解使用类C语言描述算法的方法。</li>
</ol>

<h3 id="toc_12">二、基本知识</h3>

<h4 id="toc_13">1. 数据元素是数据的基本单位</h4>

<h4 id="toc_14">2. 数据项是数据不可分割的最小单位</h4>

<h4 id="toc_15">3. 数据结构及其形式定义</h4>

<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>

<p>数据元素之间的逻辑结构有四种基本类型：</p>

<ol>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状结构或网状结构</li>
</ol>

<h4 id="toc_16">4. 关于逻辑结构域存储结构的关系及存储结构的分类的几个定义</h4>

<ol>
<li>结构定义中的“关系”描述的是数据元素之间的逻辑关系，又称逻辑结构（抽象的，与现实无关）；</li>
<li>数据结构在计算机中的表示成为数据的物理结构（存储结构）；</li>
<li><p>数据元素之间的关系在计算机中有两种不同的表示方法：</p>

<ol>
<li>顺序映像（顺序存储结构），物理结构位置相邻</li>
<li>非顺序映像（链式存储结构），指针表示关系</li>
</ol>

<p>（此处需要有图）</p></li>
</ol>

<h4 id="toc_17">5. 数据类型与抽象数据类型</h4>

<p>数据类型指的是一个值的集合和定义在该值集上的一组操作的总称。在C语言中数据类型有：基本数据类型和构造类型。</p>

<p>数据结构不同于数据类型，也不同于数据对象，它不仅要描述数据类型的数据对象，而且要描述数据对象各元素之间的相互关系。</p>

<p>抽象数据类型（ADT）细分为院子类型、固定聚合、可变聚合类型。</p>

<p>ADT的一般定义形式是：</p>

<pre><code>    ADT &lt;抽象数据类型名&gt;{
        数据对象：&lt;数据对象的定义&gt;
        数据关系：&lt;数据关系的定义&gt;
        基本操作：&lt;基本操作的定义&gt;
    } ADT &lt;抽象数据类型名&gt;
</code></pre>

<ol>
<li>其中数据对象和数据关系的定义用伪码描述。</li>
<li><p>基本操作的定义是：</p>

<pre><code>    &lt;基本操作名&gt;(&lt;参数表&gt;)
    初始条件:&lt;初始条件描述&gt;
    操作结果:&lt;操作结果描述&gt;
</code></pre>

<p>初始条件：描述操作执行之前数据结构和参数应满足的条件；若不满足，则操作失败，返回相应的出错信息。</p>

<p>操作结果：描述操作正常完成之后，数据结构的变化状况和应返回的结果。</p></li>
</ol>

<h4 id="toc_18">6. 算法的概念</h4>

<p>算法是对特定问题求解步骤的一种描述，它是指令的优先序列，其中每一条指令表示一个或多个操作。</p>

<h4 id="toc_19">7. 算法的五个特性</h4>

<ol>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>输入（0个或多个）</li>
<li>输出（0个或多个）</li>
</ol>

<h4 id="toc_20">8. 算法的设计要求</h4>

<ol>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>效率与低存储量（正确性的四个层次(？)，通常要求达到C层）</li>
</ol>

<h4 id="toc_21">9. 算法的时间复杂度</h4>

<p>常见有：O(\(1\)), O(\(n\)), O(\(n^2\)), O(\(log^2n\)), O(\(nlog^2n\)), O(\(2^n\))</p>

<p>语句频度，用归纳法计算。</p>

<h4 id="toc_22">10. 算法的空间复杂度（一般不作要求）</h4>

<h2 id="toc_23">第二章 线性表</h2>

<h3 id="toc_24">一、考纲要求</h3>

<ol>
<li>掌握线性表的逻辑结构和存储结构；</li>
<li>掌握线性表在顺序结构和链式结构上实现基本操作的方法；</li>
<li>理解线性表两种存储结构的不同特点及其适用场合，会针对需求选用合适的存储结构解决实际问题；</li>
<li>了解一元多项式的表示方法和基本运算的实现方法。</li>
</ol>

<h3 id="toc_25">二、基本知识</h3>

<h4 id="toc_26">1. 线性表及其特点</h4>

<p>线性表是n个数据元素的有效序列。线性结构特点简言之：“第一个”、“最后一个”、“前驱”、“后继”</p>

<p>完整说法：</p>

<ol>
<li>存在一个唯一的被称为“第一个”的数据元素；</li>
<li>存在一个唯一的被称为“最后一个”的数据元素；</li>
<li>除第一个元素外，每个元素均有唯一的直接前驱；</li>
<li>除最后一个元素外，每个元素均有唯一一个直接后继。</li>
</ol>

<h4 id="toc_27">2. 顺序表——线性表的顺序存储结构</h4>

<ol>
<li>特点

<ol>
<li>逻辑上相邻的元素在物理位置上相邻</li>
<li>随机访问</li>
</ol></li>
<li><p>类型定义：简言之：“数组+长度”。</p>

<p>完整说法：</p>

<pre><code>    const int MAXSIZE = 线性表最大长度;
    typedef struct {
        DataType elem[MAXSIZE]；
        int length;
    }
</code></pre>

<p>注：</p>

<ol>
<li>SqList为类型名，可换用其他写法；</li>
<li>DataType是数据元素的类型，根据需要确定;</li>
<li>MAXSIZE根据需要确定，如<code>const int MAXSIZE = 64;</code></li>
<li>课本上的SqList类型可在需要时增加存储空间，在上面这种定义下不可以。这样做避免对台内存分配，明显减少算法的复杂程度。容易理解。</li>
<li>课本上的SqList类型定义中listsize表示已经分配的空间大小（容纳数据元素的个数）。当插入元素而遇到<code>L.length=L.listsize</code>时，用<code>realloc(L.elem,L.listsize+增量)</code>重新分配内存，而<code>realloc()</code>函数则在必要的时候自动复制原来的元素到新分配的空间之中。</li>
</ol></li>
<li><p>基本形态</p>

<ol>
<li>顺序表空：条件<code>L.length==0</code>，不允许删除操作；</li>
<li>顺序表满：条件<code>L.length==MAXSIZE</code>，不允许插入操作；</li>
<li>不空不满：可以插入删除</li>
</ol></li>
<li><p>遍历算法</p>

<p>顺序访问所有元素：</p>

<pre><code>    for(i = 0; i &lt; L.length; i++){
        visit(L.elem[i]);
    }
</code></pre>

<p>查找元素x：</p>

<pre><code>    for(i = 0; i &lt; L.length; i++){
        if(L.elem[i] == X)
            break;
        if(i &lt; L.length)
            Found;
        else
            Not Found;
    }
</code></pre></li>
<li><p>插入算法</p>

<ol>
<li>前提：表不满</li>
<li>合法范围：<code>i&gt;=1&amp;&amp;i&lt;=L.length+1</code></li>
<li>步骤：

<ol>
<li>第i至最后所有元素后移一个元素</li>
<li>在第i个位置插入元素x</li>
<li>表长增加1</li>
</ol></li>
<li><p>算法</p>

<pre><code>    bool ListInsert(SqList&amp; L, int i, DataType x)
    {
        if(L.length == MAXSIZE || i&lt;i || i&gt;L.length+1) return ERROR;//失败
        //元素后移
        for(j = L.length-1; j &gt;=i-1 ; j--){//这里j为下标，从.length-1到i-1
            L.elem[j+1]=L.elem[j];//若作为位序，有如何修改？
        }
        //插入x，表长增加1
        L.elem[i-1]=x;
        L.length++;
        return OK;
    }
</code></pre></li>
</ol></li>
<li><p>删除算法</p>

<ol>
<li>前提：表非空</li>
<li>合法范围：<code>i&gt;=1&amp;&amp;i&lt;=L.length</code></li>
<li>步骤：

<ol>
<li>取出第i个元素</li>
<li>第i个元素之后的元素向前移动一个位置</li>
<li>表长减少1</li>
</ol></li>
<li><p>算法</p>

<pre><code>    bool ListDelete(SqList&amp; L, int i, DataType&amp; x)
    {
        if(L.length == MAXSIZE || i&lt;i || i&gt;L.length+1) return ERROR;//失败
        x=L.elem[i-1];
        for(j = 0; j &lt; L.length; j++){
            L.elem[j-1]=L.elem[j];
        }
        L.length--;
        return OK;//成功
    }
</code></pre></li>
</ol></li>
<li><p>算法分析</p></li>
</ol>

<table>
<thead>
<tr>
<th></th>
<th>插入</th>
<th>删除</th>
</tr>
</thead>

<tbody>
<tr>
<td>基本操作</td>
<td>移动元素</td>
<td>移动元素</td>
</tr>
<tr>
<td>平均移动次数</td>
<td>\(\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}\)</td>
<td>\(\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}\)</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>尾端操作</td>
<td>插入第n+1个元素，不移动</td>
<td>删除第n个元素，不移动</td>
</tr>
</tbody>
</table>

<ol>
<li>其他算法（函数）

<ol>
<li>InitList(&amp;L),ClearList(&amp;L): <code>L.length=0;</code></li>
<li>ListEmpty(L): <code>return L.length==0;</code></li>
<li>ListLength(L): <code>return L.length;</code></li>
<li>GetElem(L, i, &amp;e): <code>e=L.elem[i-1];</code></li>
</ol></li>
</ol>

<h4 id="toc_28">3. 单链表——线性表的链式存储结构之一</h4>

<ol>
<li>概念
  线性聊表、单链表、结点；数据域、指针域；头结点、头指针</li>
<li>特点
  用指针表示数据之间的逻辑关系（逻辑相邻的元素物理位置不一定相邻）。</li>
<li><p>类型定义<br/>
  简言之，“数据+指针”</p>

<p>完整描述：(此处应有图)</p>

<pre><code>    const int MAXSIZE = 线性表最大长度;
    typedef struct LNode {
        DataType data；
        struct LNode *next;
    } LNode, *LinkList;
</code></pre>

<ol>
<li><p>基本形态</p>

<p>带头结点的单聊表的基本形态有：</p>

<ol>
<li>单链表空：条件 <code>L-&gt;next==0</code></li>
<li>单链表不空：条件 <code>L-&gt;next!=0</code></li>
</ol></li>
<li><p>遍历算法</p>

<ol>
<li><p>顺序访问所有元素：借助指针“顺藤摸瓜”，沿着链表访问节点</p>

<pre><code>  void PrintLinkList(LinkList L)
  {
      p=L-&gt;next; //注意起始位置的考虑
      while(p!=NULL){ //判断表位，另外p!=0或均可
          print(p-&gt;data);//访问，可以换成各种操作，例如print
          p=p-&gt;next;//指针沿着链表向后移动
      }
  }
</code></pre></li>
<li><p>查找元素x</p>

<p><u><strong>方法一：</strong></u></p>

<pre><code>    //在单链表L中查找元素x
    //若找到，返回指向该节点的指针，否则返回空指针
    LinkList Find(LinkList L, DataType x)
    {
        p = L-&gt;next;
        while(p!=NULL){
            if(p-&gt;data == x) return p; //找到x
            p = p-&gt;next;
        }
        return NULL; //未找到x
    }
</code></pre>

<p>函数体内的另一种写法：</p>

<pre><code>    p = L-&gt;next;
    while(p &amp;&amp; p-&gt;data!=x)
        p = p-&gt;next;

    if(p &amp;&amp; p-&gt;data==x)
        return p; //找到x
    else
        return NULL; //未找到x
</code></pre>

<p>函数体内的第三种写法：</p>

<pre><code>    p = L-&gt;next;
    while(p &amp;&amp; p-&gt;data!=x)
        p = p-&gt;next;

    return p; //找到x，为什么可以直接写？
</code></pre>

<p><u><strong>方法二：</strong></u></p>

<pre><code>    //在单链表L中查找元素x
    //若找到，返回该元素的位序，否则返回-1
    int Find(LinkList L, DataType x)
    {
        p = L-&gt;next; j = 1；
        while(p!=NULL){
            if(p-&gt;data == x) return j; //找到x
            p = p-&gt;next;
            j++;//计数器随指针改变
        }
        return -1; //未找到x
    }
</code></pre></li>
<li><p>查找第i个元素</p>

<pre><code>    LinkList GetElem(LinkList L, int i)
    {
        p = L-&gt;next;
        j = 1;
        while(p &amp;&amp; j&lt;i){
            p = p-&gt;next;
            j++;
        }
        if(p &amp;&amp; j==i)
            return p;
        else
            return -1; //未找到x
    }
</code></pre></li>
<li><p>查找第i-1个元素</p>

<pre><code>    p=L; j=0;
    while(o &amp;&amp; j&lt;i-1){
        p = p -&gt; next; j++;
    }
    if (p &amp;&amp; j==i-1)
        return p;
    else
        return -1;
</code></pre></li>
</ol></li>
<li><p>插入算法(此处应有图)</p>

<p><strong>技巧：</strong>画图辅助分析</p>

<p><strong>思路：</strong>先查找第i-1个元素；若找到，在其后插入新节点</p>

<pre><code>   bool ListInsert(LinkList &amp;L, int i, DataType x){
    //查找第i-1个元素p
    p=L; j=0;
    while(p &amp;&amp; j&lt;i-1){
        p = p -&gt; next; j++;
    }
    //若找到，在p后插入x
    if (p &amp;&amp; j == i-1)
    {
        s = (LinkList)malloc(sizeof(LNode));
        s-&gt;data = x;
        s-&gt;next = p-&gt;next;//①
        p-&gt;next = s;//②
        return TRUE;//插入成功
    }
    else
        return FALSE;//插入失败
}
</code></pre>

<p>注意：</p>

<ol>
<li>要让p指向第i-1个而不是第i个元素（否则，不容易找到前驱以便插入）；</li>
<li>能够插入的条件：p &amp;&amp; j == i-1，即使第i个元素不存在，只要存在第i-1个元素，仍然可以插入第i个元素；</li>
<li><p>新建节点时需要动态分配内存；</p>

<p><code>s=(LinkList)malloc(sizeof(LNode));</code>    若检查是否分配成功，可用<code>if(s==NULL) exit(1); //分配失败则终止程序</code>；</p></li>
<li><p>完成插入的步骤：①②。技巧：先修改新节点的指针域。</p></li>
</ol></li>
<li><p>删除算法(此处应有图)</p>

<p>思路：先查找第i-1个元素，若找到且其后存在第i个元素，则用x返回数据，并删除之。</p>

<pre><code>bool ListDelete(LinkList &amp;L, int i, int &amp;x)
{
    //查找第i-1个元素p
    p = L; j = 0;
    while(p &amp;&amp; j&lt;i-1){
        p = p-&gt;next; j++;
    }
    //如存在第i个元素，则用x返回数据，并删除之
    if(p &amp;&amp; j==i-1 &amp;&amp; p-&gt;next){
        s = p-&gt; next; //①
        p-&gt;next=s-&gt;next; //②
        x=s-&gt;data;
        free(s);
        return TRUE;
    }
    else
        return FALSE;
}
</code></pre>

<p>注意：</p>

<ol>
<li> 要求p找到第i-1个而非第i个元素。为什么？</li>
<li><p>能够进行删除的条件：<code>p &amp;&amp; j==i-1 &amp;&amp; p-&gt;next</code>。条件中的<code>p-&gt;next</code>就是要保证第i个元素存在，否则无法删除。若写成<code>p-&gt;next &amp;&amp; j==i-1</code>也不妥，因为此时，即循环结束时，可能有<code>p==NULL</code>，所以必须先确定p不空。</p>

<p>技巧：讲条件中的“大前提”放在前面。</p>

<p>该条件也不可以写成<code>p-&gt;next &amp;&amp; p &amp;&amp; j==i-1</code>，因为先有<code>p!=0</code>才有<code>p-&gt;next</code>，上式颠倒了这一关系。</p></li>
<li><p>释放节点的方法：<code>free(s)</code>;</p></li>
<li><p>完成删除的步骤：①②</p></li>
</ol></li>
<li><p>建立链表的两种方法</p>

<p>思路：建立空表（头结点），来依次插入数据节点（每次插入表尾得(\(a_{1},a_{2},\dots,a_{n}\))，每次插入表头得(\(a_{n},\dots,a_{2},a_{1}\))）。</p>

<ol>
<li><p>顺序建表</p>

<pre><code>void CreateLinkList(LinkList &amp;L, int n){
    //建立空表
    L = (LinkList)malloc(sizeof(LNode));
    L-&gt;next = NULL; //空表
    p = L; //用p指向表尾
    //插入元素
    for (int i = 0; i &lt; n; ++i)
    {
        scanf(x);
        s = (LinkList) malloc(sizeof(LNode));
        s-&gt;data = x;
        //插入表尾
        s-&gt;next = p-&gt;next;
        p-&gt;next = s;
        p = s; //新的表尾
    }
}
</code></pre></li>
<li><p>逆序建表</p>

<pre><code>void CreateLinkList(LinkList &amp;L, int n){
    //建立空表
    L = (LinkList)malloc(sizeof(LNode));
    L-&gt;next = NULL; //空表
    //插入元素
    for (int i = 0; i &lt; n; ++i)
    {
        scanf(x);
        s = (LinkList) malloc(sizeof(LNode));
        s-&gt;data = x;
        //插入表头
        s-&gt;next = L-&gt;next;
        L-&gt;next = s;
    }
}
</code></pre></li>
</ol></li>
</ol></li>
</ol>

<h4 id="toc_29">4. 循环链表</h4>

<ol>
<li><p>特点：最后一个结点的指针指向头结点</p></li>
<li><p>类型定义：同单列表</p></li>
<li><p>基本形态(此处应有图)：空表：<code>L-&gt;next == L</code> 非空表：图</p></li>
<li><p>与单链表的联系：判断表尾的方法不同：单链表用 <code>p==NULL</code>，循环链表用<code>p==L</code>，其余操作相同。</p></li>
</ol>

<h4 id="toc_30">5. 双向循环链表</h4>

<ol>
<li>特点：一个节点包含指向后继next和指向前驱prior两个指针，两个方向又分别构成循环链表。</li>
<li><p>类型定义</p>

<pre><code>typedef struct DuLNode {
    DataType data;
    struct DuLNode *prior, *next; //两个指针
} DuLNode， *DuLinkList;
</code></pre></li>
<li><p>基本形态(此处应有图)</p>

<p>空表：用后向指针判断<code>L-&lt;next==L</code>，或者用前向指针判断<code>L-prior==L</code><br/>
非空表：图</p></li>
<li><p>与单链表和循环链表的联系</p>

<ol>
<li>最大不同：前驱容易求得，可以向前遍历；</li>
<li>判断表尾的方法与循环链表相同：<code>p==L</code>；</li>
<li>插入和删除时需要修改两个方向的指针。</li>
</ol></li>
<li><p>插入删除的相关操作</p></li>
</ol>

<table>
<thead>
<tr>
<th>p之后插入s</th>
<th>p之前插入s</th>
<th>删除p之后继承s</th>
<th>删除p</th>
</tr>
</thead>

<tbody>
<tr>
<td>s-&gt;next = p-&gt;next; <br> p-&gt;next = s;  <br> s-&gt;prior = p;  <br> s-&gt;next-&gt;prior = s;</td>
<td>s-&gt;prior = p-&gt;prior;  <br> p-&gt;prior = s; <br> s-&gt;next = p; <br> s-&gt;prior-&gt;next = s;</td>
<td>s = p-&gt;next; <br> p-&gt;next = s-&gt;next; <br> s-&gt;next-&gt;prior = p;</td>
<td>p-&gt;prior-&gt;next = p-&gt;next;  <br> p-&gt;next-&gt;prior = p-&gt;prior;</td>
</tr>
</tbody>
</table>

<h4 id="toc_31">6. 顺序表与单链表的比较</h4>

<table>
<thead>
<tr>
<th style="text-align: center">顺序表</th>
<th style="text-align: center">单链表</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">以地址相邻表示关系</td>
<td style="text-align: center">用指针表示关系</td>
</tr>
<tr>
<td style="text-align: center">随机访问，取元素O(1)</td>
<td style="text-align: center">顺序访问，取元素O(n)</td>
</tr>
<tr>
<td style="text-align: center">插入、删除需要移动元素 时间复杂度：O(n)</td>
<td style="text-align: center">插入、删除不用移动元素（用于查找位置） 时间复杂度：O(n)</td>
</tr>
</tbody>
</table>

<h2 id="toc_32">第三章 栈和队列</h2>

<h3 id="toc_33">一、考纲要求</h3>

<ol>
<li>了解栈和队列的特点；</li>
<li>掌握在两种存储结构上栈的基本操作的实现；</li>
<li>掌握栈的各种应用，理解递归算法执行过程中栈状态的变化过程；</li>
<li>掌握循环队列和链队列的基本运算；</li>
<li>会应用队列结构解决实际问题。</li>
</ol>

<h3 id="toc_34">二、基本知识</h3>

<h4 id="toc_35">1. 栈</h4>

<ol>
<li><p>几个概念：</p>

<p>栈、栈顶、栈底、空栈、后进先出（LIFO）、入栈（Push）、出栈（Pop）</p>

<p>链栈：栈的链式存储结构；顺序栈：栈的顺序存储结构。</p></li>
</ol>

<h4 id="toc_36">2. 链栈</h4>

<ol>
<li>存储结构(此处应有图)：用不带头结点的单链表实现</li>
<li>类型定义：同单链表</li>
<li><p>基本形态(此处应有图)：</p>

<ol>
<li>栈空：条件：S==NULL</li>
<li>栈非空 </li>
<li>栈满</li>
</ol></li>
<li><p>基本算法</p>

<ol>
<li><p>入栈 Push</p>

<pre><code>bool Push(LinkList &amp;s, DataType x){
    //新建节点
    p=(LinkList) malloc(sizeof(LNode));
    if(!p) return FALSE;//失败
    p-&gt;data = x;
    //插入栈顶
    p-&gt;next = s;
    s = p;
    return TRUE;
}           
</code></pre></li>
<li><p>出栈 Pop</p>

<pre><code>bool Pop(LinkList &amp;s, DataType &amp;x){
    if (s==NULL) return FALSE;
    //删除栈顶元素
    p = s;
    s = s-&gt;next;
    x = p-&gt;data;
    free(p);
    return TRUE;
}           
</code></pre></li>
<li><p>栈顶元素</p>

<p>前提：栈非空。 </p>

<pre><code>bool Top(LinkList &amp;s, DataType &amp;x){
    if(s==NULL) return FALSE; //栈空
    x = s-&gt;data;
    return TRUE;
}
</code></pre></li>
</ol></li>
</ol>

<h4 id="toc_37">3. 顺序栈</h4>

<ol>
<li><p>存储结构</p>

<p>类似于顺序表，插入和删除操作固定于结尾。</p></li>
<li><p>类型定义</p>

<p>简言之：“数组 + 长度”</p>

<p>具体定义：</p>

<pre><code>const int MAXSIZE = 栈的最大容量;
typedef struct 
{
    DataType elem[MAXSIZE];
    int top;
} SqStack;
</code></pre></li>
<li><p>基本形态</p>

<ol>
<li>栈空：条件：s.top == 0;</li>
<li>栈满：条件：s.top == MAXSIZE;</li>
<li>栈不空不满</li>
</ol></li>
<li><p>基本算法</p>

<ol>
<li><p>入栈 Push(&amp;s, x)</p>

<pre><code>bool Push(SqStack &amp;s, DataType x){
    if(s.top == MAXSIZE) return TRUE;//栈满
    s.elem[top] = x;//或者以下这两句替换为s.elem[top++] = x;
    top++;
    return TRUE;
}       
</code></pre></li>
<li><p>出栈 Pop(&amp;s, &amp;x)</p>

<pre><code>bool Pop(SqStack &amp;s, DataType &amp;x){
    if(s.top==0) return FALSE;
    top--; //或者以下这两句替换为x = s.elem[--top];
    x = s.elem[top];
    return TRUE;
}
</code></pre></li>
<li><p>栈顶元素 </p>

<p>前提：栈非空, 即是<code>s.elem[top-1]</code></p></li>
</ol></li>
</ol>

<h4 id="toc_38">4. 队列</h4>

<ol>
<li><p>几个概念：</p>

<p>队列、队头、队尾、空队列、先进先出（FIFO）</p>

<p>链队列：队列的链式存储结构； 循环队列：队列的顺序存储结构之一。</p></li>
</ol>

<h4 id="toc_39">5. 链队列</h4>

<ol>
<li>存储结构：简言之”单链表+尾指针“</li>
<li><p>类型定义</p>

<pre><code>typedef struct 
{

    LinkList front;
    LinkList rear;
} LinkQueue;
</code></pre></li>
<li><p>基本形态</p>

<p>队列空：Q.front=Q.rear</p>

<p>非空队列</p>

<p>（此处应有图）</p></li>
<li><p>基本算法</p>

<ol>
<li><p>入队列</p>

<p>插入队尾，注意保持Q.rear指向队尾。（课本P62）</p></li>
<li><p>出队列</p>

<p>删除队头元素。特别注意：如果队列中只有一个元素，则队头也同时是队尾，删除队头元素后也需要修改队尾指针。（课本P62）</p></li>
</ol></li>
</ol>

<h4 id="toc_40">6. 循环队列</h4>

<ol>
<li>存储结构：简言之”数组+头、尾位置“</li>
<li><p>类型定义</p>

<pre><code>const int MAXSIZE = 队列的最大容量;
typedef struct 
{
    DataType elem[MAXSIZE];
    int front, rear; //队头、队尾位置
} SqQueue;
</code></pre></li>
<li><p>基本形态</p>

<p>通常少用一个元素区分队列空和队列满，也可以加一标志。约定front指向队头元素的位置，rear指向队尾的下一个位置，队列内容为[front, rear)。</p>

<ol>
<li><p>队列空</p>

<p>条件：<code>Q.front==Q.rear</code></p>

<p>不能出队列</p></li>
<li><p>队列满</p>

<p>条件：<code>(Q,rear+1)%MAXSIZE==Q.front</code>(少于一个元素时)</p>

<p>不能入队列</p></li>
<li><p>队列不空也不满</p>

<p>（此处应有图）</p></li>
<li><p>加一标志区分队列空和队列满的情况</p>

<p>可以用满所有空间，队列空和队列满时都有<code>Q.front==Q.rear</code>，再用标志区分。</p>

<p>队列空：<code>Q.front==Q.rear &amp;&amp; Q.tag==0;</code></p>

<p>队列满：<code>Q.front==Q.rear &amp;&amp; Q.tag==1;</code></p></li>
</ol></li>
<li><p>基本算法</p>

<ol>
<li><p>入队列</p>

<p>前提：队列不满。</p>

<pre><code>bool EnQueue(SqQueue &amp;Q, DataType x){
    if((Q.rear+1)%MAXSIZE==Q.front)  return FALSE; // 队列满
    //入队列
    Q.elem[Q.rear]=x;
    Q.rear=(Q.rear+1)%MAXSIZE;
    return TRUE;
}
</code></pre></li>
<li><p>出队列</p>

<p>前提：队列非空。</p>

<pre><code>bool DeQueue(SqQueue &amp;Q, DataType &amp;x){
    if (Q.front==Q.rear) return FALSE; //队列空
    //出队列
    x = Q.elem[Q.front];
    Q.front = (Q.front+1)%MAXSIZE;
    return TRUE;
}
</code></pre></li>
<li><p>队列中元素个数</p>

<p>结论：<code>(Q.rear-Q.front+MAXSIZE)%MAXSIZE;</code></p>

<p>注：<code>Q.rear-Q.front</code>可能小于0，需要加上<code>MAXSIZE</code></p>

<pre><code>int QueueLength(SqQueue Q){
    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;
}
</code></pre></li>
<li><p>用标志区分队列空和满</p>

<p>用标志区分队列空和满时，队列初始化、入队列、出队列和队列长度的算法如下：</p>

<p>队列初始化：</p>

<pre><code>void InitQueue(SqQueue &amp;Q){
    Q.front = Q.rear = 0;
    Q.tag = 0;
}
</code></pre>

<p>入队列：</p>

<pre><code>bool EnQueue(SqQueue &amp;Q, DataType x){
    if (Q.front == Q.rear &amp;&amp; Q.tag) return FALSE;
    Q.elem[Q.rear] = x;
    Q.rear = (Q.rear+1)%MAXSIZE;
    if (Q.tag == 0)
        Q.tag = 1;//队列非空
    return TRUE;
}
</code></pre>

<p>出队列：</p>

<pre><code>bool DeQueue(SqQueue &amp;Q, DataType &amp;x){
    if (Q.front == Q.rear &amp;&amp; Q.tag == 0) return FALSE;
    x = Q.elem[Q.front];
    Q.front = (Q.front+1)%MAXSIZE;
    if (Q.front == Q.rear)
        Q.tag = 0; //队列空
    return TRUE;
}
</code></pre>

<p>队列长度：</p>

<pre><code>int QueueLength(SqQueue Q){
    if (Q.front == Q.rear &amp;&amp; Q.tag == 1)
        return MAXSIZE;//队列满
    else
        return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;//队列不满（包含队列空）
}
</code></pre></li>
</ol></li>
</ol>

<h4 id="toc_41">7. 栈和队列比较</h4>

<p>都是线性结构，栈的操作LIFO（后进先出），队列操作FIFO（先进先出）。</p>

<h4 id="toc_42">8. 简化的栈和队列结构</h4>

<p>在算法中使用栈和队列时可以采用简化的形式。</p>

<table>
<thead>
<tr>
<th>简化栈</th>
<th></th>
<th>简化队列</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>结构</td>
<td><code>“s[]+top&quot;</code></td>
<td>结构</td>
<td><code>“q[]+front+rear&quot;</code></td>
</tr>
<tr>
<td>初始化</td>
<td><code>top=0;</code></td>
<td>初始化</td>
<td><code>front=rear=0;</code></td>
</tr>
<tr>
<td>入栈</td>
<td><code>s[top++]=x;</code></td>
<td>入队列</td>
<td><code>q[rear]=x; rear=(rear+1)%MAXSIZE;</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>x=s[—top];</code></td>
<td>出队列</td>
<td><code>x=q[front]; front=(front+1)%MAXSIZE;</code></td>
</tr>
<tr>
<td>栈顶</td>
<td><code>s[top-1];</code></td>
<td>队列头</td>
<td><code>q[front];</code></td>
</tr>
<tr>
<td>栈空</td>
<td><code>top==0</code></td>
<td>队列空</td>
<td><code>front==rear;</code></td>
</tr>
</tbody>
</table>

<p>说明：只要栈(队列)的容量足够大，算法中可以省去检查栈(队列)满的情况。</p>

<h4 id="toc_43">9. 栈和队列的应用</h4>

<ol>
<li><p>表达式求值</p>

<p>参见课本P53</p></li>
<li><p>括号匹配</p>

<p>例：检查表达式中的括号是否正确匹配，如{()[]}正确，([)]}错误。</p>

<p>分析：每个左括号都“期待”对应的右括号，匹配成功则可以消去。</p>

<p>思路：遇到左括号则入栈，遇到右括号则与栈顶括号相比较，如果匹配则消去，否则匹配失败。当然，如果栈中没有括号可以匹配，或者最后栈中还有未匹配的左括号，也都是匹配错误（失败）。</p>

<pre><code>//检查表达式中的括号是否正确匹配
bool MatchBrackets()
{
    const int MAXSIZE = 1024;//栈的最大容量
    char s[MAXSIZE];//简化的栈结构
    int top;//栈顶
    //栈初始化
    top = 0;
    //检查括号是否匹配
    ch = getchar();
    while(ch!=EOF){
        switch(ch){
            case &#39;(&#39;,&#39;[&#39;,&#39;{&#39;:
                s[top++]=ch;//所有左括号入栈
                break;
            case &#39;)&#39;:
                if(top==0 || s[--top]!=&#39;(&#39;) return FALSE;//栈空、右括号和左括号匹配失效等条件
            case &#39;]&#39;:
                if(top==0 || s[--top]!=&#39;[&#39;) return FALSE;
            case &#39;}&#39;:
                if(top==0 || s[--top]!=&#39;{&#39;) return FALSE;
        }
        ch = getchar();//取下一个字符
    }
    if(top == 0)
        return TRUE;//完全匹配
    else
        return FALSE;//有残留的左括号在栈中，匹配失败
}
</code></pre></li>
<li><p>地柜程序的非递归化</p>

<p>将递归程序转化为非递归程序时常使用栈来实现。</p></li>
<li><p>作业排队</p>

<p>如操作系统中的作业调度中的作业排队，打印机的打印作业也排成队列。</p></li>
<li><p>按层次遍历二叉树</p>

<pre><code>//按层次遍历二叉树
void LevelOrder(BinTree bt, VisitFunc visit)
{
    const int MAXSIZE = 1024; //队列容量（足够大即可）
    BinTree q[MAXSIZE];//简化的队列结构
    int front,rear;//队头，队尾
    if(!bt) return ;
    //初始化队列，根节点入队列
    front = rear = 0;
    q[rear] = bt;
    rear = (rear+1)%MAXSIZE;
    //队列不空，则去除队头访问并将其左右孩子入队列
    while(front != rear){
        p = q[front];
        front = (front+1)%MAXSIZE;
        if (p)
        {
            visit(p-&gt;data);//访问节点
            q[rear] = p-&gt;lchild;
            rear = (rear+1)%MAXSIZE;
            q[rear] = p-&gt;rchild;
            rear = (rear+1)%MAXSIZE;
        }
    }
}
</code></pre></li>
</ol>

<h2 id="toc_44">第四章 串</h2>

<h3 id="toc_45">一、考纲要求</h3>

<ol>
<li>掌握串的基本运算的定义，了解利用基本运算来实现串的其它运算的方法；</li>
<li>了解在顺序存储结构和在堆存储结构以及块链存储结构上实现串的各种操作的方法；</li>
<li>理解KMP算法，掌握NEXT函数和改进NEXT函数的定义和计算。</li>
</ol>

<h3 id="toc_46">二、基本知识</h3>

<h4 id="toc_47">1. 概念</h4>

<p>串、空串、空格串、串的长度；子串、子串在主串中的位置、主串；串相等</p>

<h4 id="toc_48">1. 串的基本操作</h4>

<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>Assign(s, t), Create(s, cs)</code></td>
<td><code>Assign(s, t)</code> 将变量t赋值给s, <code>Create(s, cs)</code>根据字串创建变量s。</td>
</tr>
<tr>
<td><code>Equal(s, t), Length(s)</code></td>
<td><code>Equal(s, t)</code> 判断串相等, <code>Length(s)</code>求串长度，如<code>Length(“”)=0</code></td>
</tr>
<tr>
<td><code>Concat(s, t)</code></td>
<td><code>Concat(s, t)</code> 串连接。如<code>Concat(“ab”,”cd”)==“abcd&quot;</code></td>
</tr>
<tr>
<td><code>Substr(s, pos, len)</code></td>
<td><code>Substr(s, pos, len)</code> 取子串，pos为开始位置，len为子串长度</td>
</tr>
<tr>
<td><code>Index(s, t)</code></td>
<td><code>Index(s, t)</code> 求子串t在主串s中的位置。如<code>Index(“abc”,”ab”)=1, Index(“a bc”,”bc”)=3</code></td>
</tr>
<tr>
<td><code>Replace(s, t, v)</code></td>
<td><code>Replace(s, t, v)</code> 把串s中的字串t替换成v。如<code>Replace(“aaa”,”aa”,”a”)=“aa”</code></td>
</tr>
<tr>
<td><code>Delete(s, pos, len)</code></td>
<td><code>Delete(s, pos, len)</code> 删除串s的一部分</td>
</tr>
</tbody>
</table>

<h4 id="toc_49">1. 串的存储结构</h4>

<table>
<thead>
<tr>
<th>结构</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>定长顺序串</td>
<td>最大长度固定，超过最大长度则做截断处理</td>
</tr>
<tr>
<td>堆分配存储表示</td>
<td>串的长度几乎没有限制</td>
</tr>
<tr>
<td>块链存储表示</td>
<td>块内存储空间连续，块间不连续</td>
</tr>
</tbody>
</table>

<h2 id="toc_50">第五章 数组和广义表</h2>

<h3 id="toc_51">一、考纲要求</h3>

<ol>
<li>掌握数组在以行为主和以列为主的存储结构中的地址计算方法；</li>
<li>掌握矩阵压缩存储时的下标变换方法，了解以三元组表示稀疏矩阵的方法；</li>
<li>理解广义表的定义及其存储结构，理解广义表的头尾和子表两种分析方法。</li>
</ol>

<h3 id="toc_52">二、基本知识</h3>

<h4 id="toc_53">1. 数组的定义</h4>

<ol>
<li>数组：由一组类型相同、下标不同的变量构成。</li>
<li>特点：各个元素具有同一类型、下标具有固定上界和下界、基本操作简单（初始化、销毁、修改、存取）。</li>
<li>N维数组：n个下标，每个元素收到n个关系约束；一个n维数组可以看成是由若干个n-1维数组成的线性表。</li>
</ol>

<h4 id="toc_54">2. 数组的顺序存储</h4>

<p>计算机存储结构是一维的，而数组一般是多维的，那么就要进行一维化：事先约定按某种次序将数组元素排成一列序列，然后将这个线性表存入存储器中。</p>

<p>例如：二维数组可以规定按行存储，也可以规定按列存储。C中采用行优先顺序。</p>

<p>利用一维线性存储的特性，可以计算数组元素的地址计算公式：</p>

<p>\(Loc(j_1, j_2, j_3,\dots, j_n)=Loc(0,0,\dots,0)\)+ 其中\(C_n=L, C_{i-1}=b_i*c_i,1&lt;i\le n\)</p>

<p>N维数组的顺序存储表示：</p>

<pre><code>    #define MAX_ARRAY_DIM 8 //假设最大维数为8
    typedef struct
    {
        ElemType *base; //数组元素及地址
        int dim; //数组维度
        int *bound; //数组各维长度信息保存区基址
        int *constants; //数组映像函数常量的基址
    } Array;
</code></pre>

<h4 id="toc_55">3. 矩阵的压缩存储</h4>

<p>为了节省数组元素的存储空间，所谓的压缩存储就是为多个值相同的元素只分配一个存储空间：对0元素不分配空间。若值相同的元素或0元素在矩阵中的分布有一定规律，则称此类矩阵为特殊矩阵；反之，称为系数矩阵（非0元素少）。</p>

<p>那么在稀疏矩阵中如何存储那些非0元素，稀疏矩阵的表示方法：</p>

<ol>
<li>三元组：\((i, j, a_{ij})\)</li>
<li><p>十字链表：</p>

<p>（此处应有图）</p>

<p>down: 同一列中下一非零元素的指针</p>

<p>right: 同一行中下一非零元素的指针</p>

<p>每行非零元素链接成带表头结点的循环链表：每列非零元素也链接成带表头结点的循环链表。</p></li>
<li><p>三元组矩阵表：失去时机存储功能</p></li>
<li><p>带辅助向量的三元组表示：增加两个辅助向量。</p>

<p>记录每行非0元素个数，用NUM(i)表示：每行第一个非0元素在压缩后的三元组中的行号，用POS(i)表示。示例：</p>

<p>对于稀疏矩阵：</p>

<p>00 12 09 00 00 00<br/>
00 00 00 00 00 00<br/>
-3 00 00 00 14 00<br/>
00 00 24 00 00 00<br/>
00 18 00 00 00 00</p>

<p>辅助向量表：</p>

<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>

<tbody>
<tr>
<td>NUM(i)</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>POS(i)</td>
<td>1</td>
<td>3</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>

<p>POS(i)=POS(i-1)+NUM(i-1)</p>

<p>三元组矩阵表：</p>

<table>
<thead>
<tr>
<th>i</th>
<th>j</th>
<th>v</th>
</tr>
</thead>

<tbody>
<tr>
<td>6</td>
<td>6</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>9</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>-3</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>14</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>24</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>18</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>-7</td>
</tr>
</tbody>
</table>

<p>稀疏矩阵的转置实现方法：压缩转置和快速转置。（以三元组表的形式表示稀疏矩阵）</p>

<p>压缩转置：反复扫描原表序列，从j=1-n依次进行转置。</p>

<p>快速转置：生成矩阵三元组表的按列优先的辅助向量，然后实现快速转置。该辅助矩阵中num行记录第col列的非零个数，第一个cpos默认为1，之后的cpos为前一项的col和num之和。</p>

<table>
<thead>
<tr>
<th>col</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>

<tbody>
<tr>
<td>num[col]</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>cops[col]</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>8</td>
</tr>
</tbody>
</table>

<p>利用上面的辅助向量进行转置：遍历非零元素，通过元素的col列查找到相应的cpos[col]即其在转置矩阵中的位置为cpos[col]，将该元素与三元矩阵相应的第cpos[col]交换后将矩阵表中的cpos[col]++和num[col]--</p>

<p>两个算法的比较：记矩阵中列数为n，非零元素为t，m为总行数，则压缩转置时间复杂度为O(m*t)，快速转置则为O(n+t)。快速转置增设辅助向量，空间换取时间。</p></li>
</ol>

<h4 id="toc_56">4. 广义表的定义</h4>

<ol>
<li><p>广义表：元素的值非原子类型，可以再分解，表中元素也可是一个线性表；所有数据元素仍然属于同一数据类型。</p></li>
<li><p>广义表定义：广义表是线性表的推广，也称为列表。记为LS=(a1,a2,...,an)；其中表名为LS，表头为a1，表尾包括了从a2到an。</p></li>
<li><p>约定：① 用小写字母表表示原子类型，用大写字母表示列表；② 第一个元素是表头，而其余元素则组成表尾。</p>

<p>广义表中元素既可以是原子类型，也可以是列表；当每个元素都为原子且类型相同时，就是线性表。</p></li>
<li><p>特点：</p>

<ol>
<li>次序性：每个元素都有一个直接前驱和一个直接后继，首尾有点特殊性</li>
<li>有长度：表中元素个数</li>
<li>有深度：表中括号重复</li>
<li>可递归：自己作为自己的字表</li>
<li>可共享</li>
</ol></li>
</ol>

<h4 id="toc_57">5. 广义表的存储结构</h4>

<p>通常用链式结构，每个元素用一个结点表示。</p>

<ol>
<li><p>原子节点：表示原子，可设2个域或三个域。例如(tag=0, value)或(tag=0, atom, tp)，其中tp是指向表尾的指针域。</p></li>
<li><p>表结点：表示列表，若表不空，可以分解为表头和表尾。三个域：tag=1，表头指针（指向表头元素），表尾指针（指向表尾列表）。</p></li>
</ol>

<h4 id="toc_58">6. 总结</h4>

<ol>
<li>数组可以视为一种广义线性表</li>
<li>数组的存储有行/低地址优先和列/高地址优先两种不同的顺序</li>
<li>对于稀疏矩阵，有较好的亚索存储和运算方法</li>
<li>广义表是线性表的推广，也是一种线性结构</li>
<li>任何一个非空表，表头可能是原子，也可能是列表，但是表尾一定是列表</li>
</ol>

<h2 id="toc_59">第六章 树和二叉树</h2>

<h3 id="toc_60">一、考纲要求</h3>

<ol>
<li>熟练掌握二叉树的结构特点和性质，掌握二叉树各种存储结构及构建方法；</li>
<li>掌握按先序、中序、后序和层次次序遍历二叉树的算法，理解二叉树的线索化实质和方法；</li>
<li>利用二叉树的遍历求解实际问题；</li>
<li>掌握树的各种存储结构及其特点，掌握树的各种运算的实现算法；</li>
<li>掌握建立最优二叉树和哈夫曼编码的方法。</li>
</ol>

<h3 id="toc_61">二、基本知识</h3>

<h4 id="toc_62">1. 树及其有关概念</h4>

<p>树、根、子树；结点、结点的度、叶子（终端节点）、分支节点（非终端节点）、内部结点、树的度；孩子、双亲、兄弟、祖先、子孙、堂兄弟；层次（根所在层为第1层）、深度、高度；有序树、无序树（其中二叉树是有序树）；森林</p>

<h4 id="toc_63">2. 二叉树</h4>

<p>二叉树（二叉树与度为2的树不同，二叉树的度可能是0、1、2）；</p>

<p>左孩子、右孩子。</p>

<p>二叉树的五种基本形态。</p>

<h4 id="toc_64">3. 二叉树的性质</h4>

<ol>
<li>二叉树的第i层上至多有\(2^{i-1}\)个结点</li>
<li><p>深度为k的二叉树至多有\(2^k-1\)个结点</p>

<p>满二叉树：深度为k，有\(2^k-1\)个结点。<br/>
完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n个结点的完全二叉树中结点在对应满二叉树中的编号正好是从1到n。</p></li>
<li><p>叶子结点\(n_{0}\)，度为2的结点为\(n_{2}\)，则\(n_{0}=n_{2}+1\)</p>

<p>考虑结点个数：\(n=n_{0}+n_{1}n_{2}\) 考虑分支个数：\(n-1=2n_{2}+n_{1}\) 可得\(n_{0}=n_{2}+1\)</p></li>
<li><p>n个结点的完全二叉树深度为\(\lfloor logn \rfloor +1\)</p></li>
<li><p>n个结点的完全二叉树，结点按层次编号</p>

<p>有：i的双亲是\(\lfloor\frac{n}{2}\rfloor\)，如果\(i=1\)时为根（无双亲）；i的左孩子是\(2i\)，如果\(2i&gt;n\)，则无左孩子；i的右孩子是\(2i+1\)，如果\(2i+1&gt;n\)则无右孩子。</p></li>
</ol>

<h4 id="toc_65">4. 二叉树的存储结构</h4>

<ol>
<li>顺序存储结构：用数组，编号i的结点存放在[i-1]处，适合于存储完全二叉树。</li>
<li><p>链式存储结构</p>

<p>二叉链表：</p>

<pre><code>typedef struct BTNode
{
    DataType data;
    struct BTNode *lchild, *rchild;
} BTNode, *BinTree;
</code></pre>

<p>三叉链表：</p>

<pre><code>typedef struct BTNode
{
    DataType data;
    struct BTNode *lchild, *rchild, *parent;
} BTNode, *BinTree;
</code></pre>

<p>（此处应有图）</p></li>
</ol>

<h4 id="toc_66">5. 二叉树的五种基本形态</h4>

<p>（此处应有图）</p>

<ol>
<li>空树：bt==NULL</li>
<li>左右子树均空：bt-&gt;lchild == NULL &amp;&amp; bt-&gt;rchild == NULL</li>
<li>右子树为空：bt-&gt;rchild == NULL</li>
<li>左子树为空：bt-&gt;lchild == NULL</li>
<li>左右子树均非空、前两种常作为递归结束条件，后三者常需要递归。</li>
</ol>

<h4 id="toc_67">6. 遍历二叉树</h4>

<ol>
<li><p>常见有四种遍历方式</p>

<p>按层次遍历：先序遍历（DLR）、中序遍历（LDR）、后序遍历（LRD）。“从上至下，从左至右”，利用队列。</p></li>
<li><p>先序遍历算法</p>

<pre><code>void PreOrder(BinTree bt){
    if (bt)
    {
        visit(bt-&gt;data);
        PreOrder(bt-&gt;lchild);
        PreOrder(bt-&gt;rchild);
    }
}
</code></pre></li>
<li><p>中序遍历算法</p>

<pre><code>void InOrder(BinTree bt){
    if (bt)
    {
        InOrder(bt-&gt;lchild);
        visit(bt-&gt;data);
        InOrder(bt-&gt;rchild);
    }
}
</code></pre></li>
<li><p>后序遍历算法</p>

<pre><code>void PostOrder(BinTree bt){
    if (bt)
    {
        PostOrder(bt-&gt;lchild);
        PostOrder(bt-&gt;rchild);
        visit(bt-&gt;data);
    }
}
</code></pre></li>
<li><p>按层次遍历</p>

<p>思路：利用一个队列，首先将根（头指针）入队列，以后若队列不空则取队头元素p，如果p不空，则访问之，然后将其左右子树入队列，如此循环直到队列为空。</p>

<pre><code>void LevelOrder(BinTree bt){
    //队列初始化为空
    InitQueue(Q);
    //根入队列
    EnQueue(Q, bt);
    //队列不空则继续遍历
    while(!QueueEmpty(Q)){
        DeQueue(Q, p);
        if(p!=NULL){
            visit(p-&gt;data);
            //左右子树入队列
            EnQueue(Q, p-&gt;lchild);
            EnQueue(Q, p-&gt;rchild);
        }
    }
}
</code></pre></li>
</ol>

<p>若队列表示为“数组q[]+头尾front, rear”有：</p>

<pre><code>    void LevelOrder(BinTree bt){
        const int MAXSIZE = 1024;
        BinTree q[MAXSIZE];
        int front, rear;
        //队列初始化为空
        front = rear = 0;
        //根入队列
        q[rear] = bt;
        rear = (rear+1) % MAXSIZE;
        //队列不空则循环
        while(front!=rear){
            p = q[front];
            front = (front+1) % MAXSIZE;
            if (p)
            {
                visit(p-&gt;data);
                //左右子树入队列
                q[rear] = p-&gt;lchild;
                rear = (rear+1) % MAXSIZE;
                q[rear] = p-&gt;rchild;
                rear = (rear+1) % MAXSIZE;
            }
        }
    }
</code></pre>

<ol>
<li><p>非递归遍历二叉树</p>

<p>一般借助栈实现，设想一指针沿二叉树中序顺序移动，每当向上层移动时就要出栈。</p>

<ol>
<li><p>中序非递归遍历</p>

<p>指针p从根开始，首先沿着左子树向下移动，同时入栈保存；当到达空子树后需要退栈访问节点，然后移动到右子树上去。</p>

<pre><code>void InOrder(BinTree bt, VisitFunc visit){
    InitStack(S);
    p = bt;
    while(p || !StackEmpty(S)){
        if (p)
        {
            Push(S, p);
            p = p-&gt;lchild;
        }
        else
        {
            Pop(S, p);
            visit(p);//中序访问节点的位置
            p = p-&gt;rchild;
        }
    }
}       
</code></pre></li>
<li><p>先序非递归遍历</p>

<p>按照中序遍历的顺序，将访问结点的位置放在第一次指向该结点时。</p>

<pre><code>void PreOrder(BinTree bt, VisitFunc visit){
    InitStack(S);
    p = bt;
    while(p || !StackEmpty(S)){
        if (p)
        {
            visit(p); //先序访问结点的位置
            Push(S, p);
            p = p-&gt;lchild;
        }
        else
        {
            Pop(S, p);
            p = p-&gt;rchild;
        }
    }
}
</code></pre>

<p>或者，由于访问过的结点便可以弃之不用，只要能访问其左右子树即可，写出如下算法。</p>

<pre><code>void PreOrder(BinTree bt, VisitFunc visit){
    InitStack(S);
    Push(S, bt);
    while(!StackEmpty(S)){
        Push(S, p);
        if (p)
        {
            visit(p); 
            Push(S, p-&gt;rchild); //先进栈，后访问，所以这里先让右子树进栈
            Push(S, p-&gt;lchild);
        }
    }
}
</code></pre></li>
<li><p>后序非递归遍历</p>

<p>后序遍历时，分别从左子树和右子树共两次返回根节点，只有从右子树返回时才访问根节点，所以增加一个栈标记到达结点的次序。</p>

<pre><code>void PostOrder(BinTree bt, VisitFunc visit){
    InitStack(S);
    InitStack(tag);
    p = bt;
    while(p||!StackEmpty(S)){
        if (p)
        {
            Push(s, p);
            Push(tag, 1);//第一次入栈
        }
        else
        {
            Pop(S, p);
            Pop(tag, f);
            if(f==1){
                //从左子树返回，二次入栈，然后p转右子树
                Push(S, p);
                Push(tag, 2);
                p = p-&gt;rchild;
            }
            else
            {
                //从右子树返回（二次出栈），访问根节点，p转上层
                visit(p);
                p = NULL; // 必须的，使下一步继续推栈
            }
        }
    }
}
</code></pre>

<p>注：后序非递归遍历的过程中，栈中保留的是当前结点的所有祖先。这是和先序及中序遍历不同的。在某些和祖先有关的算法中，此算法很有价值。</p></li>
</ol></li>
</ol>

<p>7.三叉链表的遍历算法</p>

<pre><code>    //中序遍历三叉链表存储的二叉树
    void InOrder(BinTree bt, VisitFunc visit){
        if (bt == NULL)  return ; //空树，以下考虑非空树
        //找到遍历的七点
        p = bt; //注意：这里p!=NULL
        while(p-&gt;lchild) p = p-&gt;lchild;
        //开始遍历
        while(p){
            //访问结点
            visit(p);
            //p转下一个结点
            if(p-&gt;rchild){ // 右子树不空，下一个在右子树
                p = p-&gt;rchild;
                while(p-&gt;lchild) p = p-&gt;lchild; // 转右子树的最左下结点
            }
            else
            { // 右子树为空，下一个在上层
                f = p-&gt;parent;
                while(p == f-&gt;rchild){ // 若p是右子树则一直上溯
                    p = f;
                    f = f-&gt;parent;
                }
            }
        }
    }
</code></pre>

<h4 id="toc_68">7. 遍历二叉树的应用</h4>

<ol>
<li>写出遍历序列（前、中、后序）（此处应有图）</li>
<li>根据遍历序列画出二叉树</li>
<li>编写算法</li>
</ol>

<h4 id="toc_69">8. 线索二叉树</h4>

<ol>
<li><p>线索</p>

<p>n个结点的二叉链表中有n+1个空指针，可以利用其指向前驱或后继界定啊，叫线索，同时需附加一个标志，区分是子树还是线索。</p>

<p>（此处应有图）</p>

<p>lchild 有左子树，则指向左子树，标志<code>ltag==0</code>；没有左子树，可作为前驱线索，标志<code>ltag==1</code></p>

<p>rchild 有右子树，则指向右子树，标志<code>rtag==0</code>；没有右子树，课作为后继线索，标志<code>rtag==1</code></p></li>
<li><p>线索化二叉树</p>

<p>利用空指针作为线索指向前驱或后继。左边空指针可以作为前驱线索，右边空指针可以做为后继线索，可以全线索化或部分线索化。</p>

<table>
<thead>
<tr>
<th></th>
<th>前驱、后继线索</th>
<th>前驱线索</th>
<th>后继线索</th>
</tr>
</thead>

<tbody>
<tr>
<td>中序线索化</td>
<td>中序全线索</td>
<td>中序前驱线索</td>
<td>中序后继线索</td>
</tr>
<tr>
<td>前序线索化</td>
<td>前序全线索</td>
<td>前序前驱线索</td>
<td>前序后继线索</td>
</tr>
<tr>
<td>后序线索化</td>
<td>后序全线索</td>
<td>后序前驱线索</td>
<td>后序后继线索</td>
</tr>
</tbody>
</table></li>
<li><p>画出线索二叉树</p>

<p>思路：先写出遍历序列，再画线索。<br/>
步骤：</p>

<ol>
<li>标出必要的空指针（前驱-&gt;左指针；后继：-&gt;右指针。要点：不要多标，也不要少标）</li>
<li>写出对应的遍历序列（前序、中序或后序）</li>
<li>对照遍历结果画线索。</li>
</ol>

<p>（此处应有例子）</p></li>
<li><p>遍历线索二叉树</p>

<p>反复利用孩子和线索进行遍历，可以避免递归。</p></li>
</ol>

<h4 id="toc_70">9. 树和森林</h4>

<ol>
<li><p>树的存储结构</p>

<p>双亲表示法、孩子表示法、孩子兄弟表示法。</p></li>
<li><p>树与二叉树的转换</p>

<table>
<thead>
<tr>
<th>树</th>
<th>对应的二叉树</th>
</tr>
</thead>

<tbody>
<tr>
<td>根</td>
<td>根</td>
</tr>
<tr>
<td>第一个孩子</td>
<td>左孩子</td>
</tr>
<tr>
<td>下一个兄弟</td>
<td>右孩子</td>
</tr>
</tbody>
</table>

<p>特点：由树转化成的二叉树，根节点没有有孩子</p>

<p>（此处应有例子）</p></li>
<li><p>森林与二叉树的转换</p>

<p>森林中第1棵树的根作为对应的二叉树的根；其他的树看做第1棵树的兄弟；森林中的树转换成对应的二叉树。则森林转换成对应的二叉树。</p>

<p>例：将森林转换成对应的二叉树。课本 P138</p></li>
<li><p>树的遍历</p>

<p>树的结构：①根 ②根的子树<br/>
先根遍历：①②。例：ABCDEFGHIJK<br/>
后根遍历：②①。例：CEDFBHGJKIA</p></li>
<li><p>遍历森林</p>

<p>森林的结构：①第一棵树的根 ②第一棵树的子树森林 ③其余树（除第1棵树外）组成的森林。<br/>
先序遍历：①②③。例：ABCDEFGHIJ<br/>
中序遍历：②①③。例：BDCEAGFIJH<br/>
注：先序遍历森林，相当于依次先根遍历每一棵树；中根遍历森林相当于后根遍历每一棵树。</p>

<p>（此处应有图）</p>

<table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>

<tbody>
<tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody>
</table></li>
</ol>

<h4 id="toc_71">10. 赫夫曼树及其应用</h4>

<ol>
<li><p>最优二叉树（赫夫曼/哈夫曼树）</p>

<p>树的带权路径长度：所有叶子结点的带权路径长度之和：\(\sum_{k=1}^{n}w_kl_k\)，其中，路径长度\(l_k\)按照分支数目计算。</p></li>
<li><p>构造赫夫曼树</p>

<p>算法：课本 P145<br/>
简单说：“每次取连个最小的树组成二叉树”</p></li>
<li><p>赫夫曼码（前缀码）</p>

<p>向左分支为0，向右分支为1，从根到叶子的路径构成叶子的前缀编码。</p></li>
</ol>

<p>（此处应有例题）</p>

<h2 id="toc_72">第七章 图</h2>

<h3 id="toc_73">一、考纲要求</h3>

<ol>
<li>熟练掌握图的基本概念，会构建各种图的存储结构；</li>
<li>掌握深度优先搜索遍历图和广度优先搜索遍历图的算法；</li>
<li>灵活运用图的遍历算法求解各种路径问题，包括最小生成树﹑最短路径﹑拓扑排序﹑关键路径等。</li>
</ol>

<h3 id="toc_74">二、基本知识</h3>

<h4 id="toc_75">1. 图的有关概念</h4>

<p>图、顶点、弧、弧头、弧尾；<br/>
有向图（顶点集+弧集）（\(0\le e\le n(n-1)\)）、无向图（顶点集+边集）；<br/>
稀疏图（\(e&lt;nlogn\)）、稠密图；<br/>
完全图（\(e=n(n-1)/2\)）、有向完全图；<br/>
网、有向网、无向网；<br/>
子图、邻接点、顶点的度、入度、出度；<br/>
路径、路径长度（经过边或弧的数目）、简单路径、回路（环）、简单回路（简单环）；<br/>
连通图、连通分量、强连通分量</p>

<h4 id="toc_76">2. 图的存储结构</h4>

<ol>
<li><p>图的存储结构</p>

<p>常见的存储结构有：邻接矩阵、邻接表、逆邻接表、十字链表、邻接多重表</p>

<p>邻接多重表只适用于存储无向图，其他存储结构可以存储无向图和有向图。</p></li>
<li><p>邻接矩阵</p>

<p>简言之，“数组（顶点）+二维数组（弧）+个数”</p>

<pre><code>const int MAX_VERTEX = 最大顶点个数;
typedef struct Graph //图
{
    VertexType vexs[MAX_VERTEX]; //顶点向量
    ArcType arcs[MAX_VERTEX][MAX_VERTEX]; //邻接矩阵
    int vexnum, arcnum; //顶点和弧的个数
};
</code></pre>

<p>图：有边（弧）为1；否则为0.网：有边（弧）为权值；否则为\(\infty\)。存储空间个数为\(n^2\)，与边的数目无关。无向图的邻接矩阵是对称的。</p></li>
</ol>

<table>
<thead>
<tr>
<th>A</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>0</th>
</tr>
</thead>

<tbody>
<tr>
<td>B</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<ol>
<li><p>邻接表</p>

<p>简言之，“数组（弧尾顶点）+链表（邻接点）+个数”</p>

<pre><code>typedef struct ArcNode
{
    int adjvex; //邻接点
    struct ArcNode *nextarc; //下一个邻接点
} ArcNode;

typedef struct VexNode
{
    VertexType data; //顶点信息
    ArcNode *firstarc; //第一个邻接点
} VexNode;

const int MAX_VERTEX = 最大顶点个数;

typedef struct Graph
{
    VexNode vexs[MAX_VERTEX]; //顶点向量
    int vexnum, arcnum; //顶点和弧的个数
} Graph;
</code></pre>

<p>边（弧）多则需要存储空间多。</p>

<p>（此处应有图）</p></li>
<li><p>逆邻接表</p>

<p>简言之，“数组（弧头顶点）+链表（逆邻接点）+个数”。类型定义类似邻接表。</p>

<p>（此处应有图）</p></li>
<li><p>十字链表</p>

<p>简言之，“数组（弧尾顶点）+链表（邻接点）+个数”。边可以看做两条弧。</p>

<pre><code>typedef struct ArcNode //弧结点
{
    int vtail, vhead; //弧尾和弧头顶点编号
    struct ArcNode *nexttail, *nexthead; //指向同弧尾和同弧头的弧结点
} ArcNode;

typedef struct VexNode //顶点结点
{
    VertexType data; //顶点信息
    ArcNode *firstin, *firstout; //指向第一条入弧和第一条出弧
} VexNode;

const int MAX_VERTEX = 最大顶点个数;

typedef struct Graph //图
{
    VexNode vexs[MAX_VERTEX]; //顶点向量
    int vexnum, arcnum; //顶点和弧的个数
} Graph;
</code></pre>

<p>弧结点中包含两个指针分别指向同一弧头的下一个弧和同一个弧尾的下一个弧。顶点结点则指向第一个同弧头和弧尾的弧。十字链表相当于邻接表和逆邻接表的结合。</p>

<p>技巧：把弧结点按行排列整齐，然后画链表。同弧尾的弧组成链表，同弧头的弧组成链表。</p></li>
<li><p>邻接多重表</p>

<p>简言之，“数组（顶点）+边结点”。</p>

<pre><code>typedef struct EdgeNode
{ //边结点
    int vexi, vexj; // 边的两个顶点
    struct EdgeNode *nexti, *nextj; //两个顶点所依附的下一条边
} EdgeNode;

typedef struct VexNode
{ //顶点结点
    VertexType data; // 顶点信息
    EdgeNode *firstedge; // 指向第一条边
} VexNode;

const int MAX_VERTEX = 最大顶点个数;

typedef struct  Graph
{ // 图
    VexNode vexs[MAX_VERTEX]; // 顶点向量
    int vexnum,edgenum; // 顶点和边的个数
} Graph;
</code></pre>

<p>只适合存储无向量图，不能存储有向图。</p>

<p>（此处应有图）</p>

<p>技巧：把边结点按列排整齐，然后画链表。相同顶点组成链表，这里没有起点和终点的区别。</p></li>
</ol>

<h4 id="toc_77">3. 图的遍历</h4>

<ol>
<li><p>深度优先搜索</p>

<ol>
<li><p>遍历方法</p>

<p>从图中某个顶点出发，访问此顶点，然后依次从其未被访问的邻接点出发深度优先遍历图；若图中尚有顶点未被访问，则另选图中一个未被访问的顶点作为起始点，重复上述过程，直到图中所有顶点都被访问为止。</p></li>
<li><p>分析方法</p>

<p>方法：画一棵“深度优先搜索树”</p>

<p>（例）</p></li>
<li><p>算法</p>

<pre><code>void DFSTraverse(Graph G){
    visited[0 ... G.vexnum-1] = FALSE; // 初始化访问标志为未访问（FALSE）
    for (int v = 0; v &lt; G.vexnum; ++v)
    {
        if(!visited[v])
            DFS(G,v); // 从未被访问的顶点开始DFS
    }
}

void DFS(Graph G, int v){
    visit(v);
    visited[v]=TRUE; // 访问顶点v并做标记
    for (w = FirstAdjVex(G, v); w &gt;= 0; w=NextAdjVex(G,v,w))
    {
        if (!visited[w])
            DFS(G, w); // 分别从每个未访问的邻接点开始DFS
    }
}
</code></pre>

<p>其中的FirstAdjVex(G, v)表示图G中顶点v的第一个邻接点，NextAdjVex(G,v,w)表示图G中顶点v的邻接点w之后v的下一个邻接点。深度优先搜索算法有广泛的应用，以上算法是这些应用的基础。</p></li>
</ol></li>
<li><p>广度优先搜索</p>

<ol>
<li><p>遍历方法</p>

<p>从图中某顶点出发，访问此顶点之后依次访问其各个未被访问的邻接点，然后从这些邻接点出发一次访问他们的邻接点，并使“先被访问的顶点的邻接点”要先于“后被访问的顶点的邻接点”被访问，直至所有已被访问的顶点的邻接点都被访问。若图中尚有顶点未被访问，则另选图中未被访问的顶点作为起始点，重复以上过程，直到图中所有顶点都被访问为止。广度优先搜索从某顶点出发，要依次访问路径长度为1、2、... 的顶点。 </p></li>
<li><p>分析方法</p>

<p>方法：画一棵“广度优先搜索树”</p>

<p>（例）</p></li>
<li><p>算法</p>

<p>利用队列（类似按层遍历二叉树）：</p>

<pre><code>void BFSTraverse(Graph G){
    visited [0 ... G.vexnum-1] = FALSE; //
    InitQueue(Q);
    for (int v = 0; v &lt; G.vexnum; ++v)
    {
        if (!visited[v])
        {
            //
            visit(v);
            visited[v] = TRUE;
            EnQueue(Q, v);
            while(!QueueEmpty(Q)){
                DeQueue(Q, u);
                for (w = FirstAdjVex(G, v); w &gt;= 0; w=NextAdjVex(G,v,w))
                {
                    if (!visited[w])
                    {
                        visit(w);
                        visited[w] = TRUE;
                        EnQueue(Q, w);
                    }
                }
            }
        }
    }
}
</code></pre></li>
</ol></li>
<li><p>时间复杂度分析</p>

<p>观察搜索树可以看出，无论是深度优先搜索还是广度优先搜索，其搜索过程就是对每个顶点求所有邻接点的过程。当用邻接表存储图时，其时间复杂度为\(O(n+e)\)；当采用邻接矩阵作为存储结构时，时间复杂度是\(O(n^2)\)（因为求一个顶点的所有邻接点就是搜索邻接矩阵的一行中的n个树，而顶点的个数为n，总共就是\(n^2\)）</p></li>
</ol>

<h4 id="toc_78">4. 最小生成树</h4>

<ol>
<li><p>最小生成树及MST性质</p>

<p>概念：最小生成树、MST性质</p>

<p>注意：同一个连通网的最小生成树可能是不唯一的，但其代价都是最小（唯一的）。</p></li>
<li><p>克鲁斯卡尔算法</p>

<p>一句话，“不构成环的情况下，每次选取最小边”</p>

<p>（此处应有图）</p></li>
<li><p>普利姆算法</p>

<p>记V是连通的顶点集，U是求得生成树的顶点集，TE是求的生成树的边集。</p>

<p>普利姆算法：</p>

<ol>
<li>开始时，\(U={v_0},TE=\Phi\)；</li>
<li>计算U到其余顶点V-U的最小代价，将该顶点纳入，边纳入TE；</li>
<li>重复上一步直到U=v。</li>
</ol>

<p>（例）</p></li>
<li><p>两种算法的比较</p></li>
</ol>

<table>
<thead>
<tr>
<th>算法</th>
<th>普利姆算法</th>
<th>克鲁斯卡尔算法</th>
</tr>
</thead>

<tbody>
<tr>
<td>时间复杂度</td>
<td>\(O(n^2)\)</td>
<td>\(O(eloge)\)</td>
</tr>
<tr>
<td>特点</td>
<td>只与顶点个数n有关，与边的数目e无关，适用于稠密图</td>
<td>只与边的数目e有关，与顶点个数n无关，适用于稀疏图</td>
</tr>
</tbody>
</table>

<h4 id="toc_79">5. 拓扑排序</h4>

<p>有向无环图（DAG）、AOV网、拓扑排序</p>

<p>拓扑排序，一句话“每次删除入度为0的顶点并输入之”。</p>

<p>（例）</p>

<p>注意：拓扑排序的结果不一定是唯一的。如：ACBDE也是以上DAG图的拓扑有序序列。</p>

<h4 id="toc_80">6. 关键路径</h4>

<ol>
<li><p>AOE网、关键路径</p>

<p>AOE网（活动在边上），边代表活动或任务，顶点代表事件。事件i发生后，其后继活动<code>a(i,*)</code>都可以开始；只有所有先导活动<code>a(*,j)</code>都结束后，事件j才发生。</p>

<p>（图）</p></li>
<li><p>关键路径算法</p>

<p>问题：</p>

<ol>
<li>整个工程完工需要多长时间？</li>
<li>哪些活动影响工程进度？或求关键路径。</li>
</ol>

<p>事件（顶点）i：最早发生时间ve(i)，最晚发生时间vl(i)；</p>

<p>活动（边）a(i, j)：最早开始时间e(i, j)，最晚开始时间l(i, j)。</p>

<p>于是，整个工程完工的时间就是终点的最早发生时间；关键路径就是路径长度最长的路径。</p>

<p>求关键路径的算法：</p>

<ol>
<li>按拓扑有序排列顶点：对顶点拓扑排序</li>
<li>计算ve(j)：<code>ve(1)=0, ve(j) = max{ve(*)+a(*, j)}</code>，其中*为任意前驱事件；</li>
<li>计算vl(i)：<code>vl(n)=ve(n), vl(i) = min{vl(*)-a(i, *)}</code>，其中*为任意后继事件；</li>
<li>计算e(i, j)和l(i, j)：<code>e(i, j)=ve(i), l(i, j)=vl(j)-a(i, j)</code></li>
<li>结论：工程总用时ve(n)，关键活动是e(i, j)=l(i, l)的活动a(i, j)。</li>
</ol>

<p>说明：</p>

<ol>
<li>若只求工程的总用时只要进行步骤i-ii即可求得。</li>
<li>如何理解计算ve(j)和vl(i)的公式：事件j在所有前驱活动都完成后发生，所以其最早发生时间<code>ve(j)=max{ve(*)+a(*,j)}</code>，即取决于最慢的前驱活动。另一方面，事件i发生后所有后继活动都可以开始了，所以其最晚发生时间<code>vl(i)=min{vl(*)-a(i, *)}</code>，即不耽误最慢的后继活动。 </li>
</ol>

<p>（例）</p></li>
</ol>

<h4 id="toc_81">7. 最短路径</h4>

<ol>
<li><p>迪杰斯特拉算法</p>

<p>求一个顶点到其他各项顶点的最短路径。</p>

<p>算法：</p>

<ol>
<li>初始化：用起点v到该顶点w的直接边（弧）初始化最短路径，否则设为\(\infty\)；</li>
<li>从未求得最短路径的终点中选择路径长度最小的终点u：即求得v到u的最短路径；</li>
<li>修改最短路径：计算u的邻接点的最短路径，若\((v,\dots,u)+(u,w)&lt;(v,\dots,w)\)，则以\((v,\dots,u,w)\)代替。</li>
<li>重复ii-iii，直到求得v到其余所有顶点的最短路径。</li>
</ol>

<p>特点：总是按照从小到大的顺序求得最短路径。</p>

<p>（例）</p></li>
<li><p>弗洛伊德算法</p>

<p>求每对顶点之间的最短路径。</p>

<p>依次计算\(A^{(0)},A^{(1)},\dots A^{(n)},\)。\(A^{(0)}\)为邻接矩阵，计算\(A^{(k)}\)的技巧。第k行、第k列、对角线的元素保持不变，对其余元素，考察A(i, j)与A(i, k)+A(k, j)（“行+列”，即第k列i“行”元素加上第k行j“列”元素）。如果后者更小则替换A(i, j)，同时求改路径。</p>

<p>（图）</p>

<p>技巧：当不变行或不变列（即第k行、第k列）某元素为\(\infty\)时，其所在的列或行元素也不变。例如：计算\(A^{(1)}\)时，\(A(2,1)=A(3,1)=\infty\)，所以第2、3行都不变，而A(1,4)=\(\infty\)，所以第4列也不变。这样，只剩下A(4,2)和A(4,3)需要计算了。</p></li>
</ol>

<h4 id="toc_82">8. 动态存储结构</h4>

<ol>
<li>了解伙伴算法、了解边界标识法

<ol>
<li>动态存储管理研究的基本问题：系统如何按用户的要求分配内存；当用户使用完毕，系统如何回收内存。</li>
<li>“占用块”：分配给用户使用的地址连续的内存区。</li>
<li>“空闲块”：未曾分配的地址连续的内存区，也称“可利用空间块”</li>
<li>可利用空间表：把可利用空间表看做是一个“存储池”，它有以下三种不同的结构形式：

<ol>
<li>系统运行期间所有用户请求分配的存储量大小相同；</li>
<li>系统运行期间用户请求分配的存储量有几种大小的规格；</li>
<li>系统在运行期间分配给用户的内存块大小不固定。 </li>
</ol></li>
</ol></li>
</ol>

<h2 id="toc_83">第八章 查找</h2>

<h3 id="toc_84">一、考纲要求</h3>

<ol>
<li>熟练掌握各种静态查找和动态查找算法，会计算查找成功时和失败时的平均查找长度；</li>
<li>掌握二叉排序树的建立、插入和删除过程，掌握二叉平衡树的建立和旋转平衡方法；</li>
<li>掌握B-树的建立、插入和删除结点的过程；</li>
<li>熟练掌握哈希表的构造方法和处理冲突的方法。</li>
</ol>

<h3 id="toc_85">二、基本知识</h3>

<h4 id="toc_86">1. 查找的有关概念</h4>

<p>查找表、静态查找表（只进行“查找”）、动态查找表（可“查找”、“插入”、“删除”）、关键词、平均查找长度</p>

<p>\(ASL=\sum_{i=1}^{n}p_i c_i\)</p>

<p>其中 ,\(p_i\)第i个关键字出现的概率，\(c_i\)比较的关键字的个数。</p>

<p>静态查找表：顺序查找表、折半查找表、静态树表、次优查找树、索引顺序表。</p>

<p>动态查找表：二叉排序树、平衡二叉树（AVL树）、B-树、B+树、键树、哈希表。</p>

<h4 id="toc_87">2. 顺序查找</h4>

<ol>
<li>思路：按顺序逐个比较，直到找到或找不到</li>
<li><p>算法：程序，灵活运用</p>

<p>例如，在数组a的前n个元素中查找x</p>

<pre><code>int Search(int a[], int n, int x){
    for (int i = n-1; i &gt;= 0; i--)
    {
        if (a[i]==x)
            return i;
        return -1; //-1表示找不到
    }
}
</code></pre>

<p>编程技巧：所有执行路径都要有正确的返回值，不要忘记最后那个return语句。</p>

<p>应试技巧：题目要求不明确时，按照方便的方法做，用适当的注释说明。</p></li>
<li><p>分析</p>

<p>顺序查找特点：思路简单（逐个比较）、适用面广（对查找表没有特殊要求）</p>

<ol>
<li><p>平均查找长度</p>

<p>一般在等概率情况下，查找成功时，平均查找长度：\(ASL=\frac{1+2+\dots+n}{n}=\frac{n+1}{2}\)。思路：假设对每个元素进行1次查找，共进行n次查找，计算出进行比较的关键字的个数，然后除以查找次数n，就求得平均查找长度。</p>

<p>例：10个元素的表等概率情况下查找成功时的平均查找长度\(ASL=\frac{1+2+\dots+10}{10}=5.5\)</p></li>
<li><p>判定树</p>

<p>判定树是一种描述查找中比较过程的直观形式，每个关键词所在层次就是其查找长度，有利于分析查找过程。顺序查找的判定树是一颗深度为n的单分支的树。课本上顺序查找从\(a_n\)开始，当然也可以从\(a_1\)开始。</p></li>
<li><p>时间复杂度</p>

<p>从平均查找长度看顺序查找的时间复杂度是O(n)。</p></li>
</ol></li>
</ol>

<h4 id="toc_88">3. 折半查找</h4>

<ol>
<li><p>思路</p>

<p>待查找的表必须是有序的，先从中间开始比较，比较一次至少抛弃一般元素，逐渐缩小范围，知道查找成功或失败。</p></li>
<li><p>算法</p>

<p>要熟练掌握该算法。设a[]升序有序，有以下算法：</p>

<pre><code>int BinarySearch(DataType a[], int n, DataType x){
    low = 0;
    high = n-1;
    while(low &lt;= high){
        mid = (low+high)/2; //折半
        if(a[mid]==x)
            return mid; //找到
        else if (x&lt;a[mid])
            high=mid-1;//x位于低半区[low...mid-1]
        else
            low=mid+1;//x位于高半区[mid+1...high]
    }
    return -1;//-1表示未找到
}
</code></pre>

<p>或者有递归版本：</p>

<pre><code>int BinarySearch(DataType a[], int low, int high, DataType x){
    if (low&gt;high)
        return -1;//查找失败
    mid = (low+high)/2;//折半
    if (a[mid]==x)
        return mid;//找到
    else if(x&lt;a[mid])
        return BinarySearch(a, low, mid-1, x);
    else
        return BinarySearch(a, mid+1, high, x);
}
</code></pre>

<p>另外，程序可有多种写法。</p>

<p>（例）</p></li>
<li><p>分析</p>

<p>特点：速度很快，要求查找表是有序的，而且随机访问（以便计算折半的下标）。所以，链表不能进行折半查找（但可以采用二叉排序树等形式进行快速的查找）。</p>

<ol>
<li><p>判定树</p>

<p>折半查找的判定树类似于完全二叉树，叶子结点所在层次之差最多为1，其深度为\(\lfloor logn\rfloor+1\)。查找过程就是走了一条从根到该结点的路径。</p>

<p>（例）</p></li>
<li><p>平均查找长度</p>

<p>结论：等概率查找成功时的平均查找长度：\(ASL_{bs}=\frac{1}{n} \sum_{j=1}^{h}j2^{j-1}=\frac{n+1}{n}log(n+1)-1\thickapprox^{n&gt;50}log(n+1)-1\)</p>

<p>分析方法：对等概率情况，假设查找n次，且每个查找1次，共比较关键字c次，则平均\(\frac{c}{n}\)次。</p>

<p>例：表长为n=10，平均查找长度如下：\(ASL=\frac{3+2+3+4+1+3+4+2+3+4}{10}=\frac{29}{10}=2.9\)</p></li>
<li><p>时间复杂度</p>

<p>结论：O(logn)，根据平均查找长度计算。</p>

<p>有时对需要反复查找的数据预先排序，再折半查找也是划算的。比如有1000个数据，顺序查找100次，平均比较约\(100\times500=50000\)次；快排大约比较\(1.44nlogn=1。44\times1000\times10=14400\)，100次折半查找比较不超过\(100\times9\times2=1800\)次（考虑到同一关键字的两次比较），排序后折半查找合计比较不超过大约16200次。</p></li>
</ol></li>
</ol>

<h4 id="toc_89">4. 索引顺序表</h4>

<p>分块，块间有序+块内无序，对应索引表有序+顺序表（无序）。索引顺序表的查找性能介于顺序查找与折半查找之间。</p>

<p>分块的最佳长度是是多少？</p>

<p>规定条件：每块的大小相同，对块索引表和块内查找均采用顺序查找。设表长为n，等分成b块，采用顺序查找确定块需要比较\(\frac{b+1}{2}\)次，块内顺序查找比较\(\frac{\frac{n}{b+1}}{2}\)次，总共\(C(b)=\frac{b+1}{2}+\frac{\frac{n}{b+1}}{2}\)，要使C(b)最小，有\(b=\sqrt{n}\)。</p>

<h4 id="toc_90">5. 二叉树排序</h4>

<ol>
<li><p>二叉排序树</p>

<p>二叉排序树或为空树；或者是这样一棵二叉树，若左子树不空，则左子树上所有结点均小于根节点，若右子树不空，则右子树上所有结点均大于根节点，其左、右子树也是二叉排序树。</p>

<p>技巧：如果中序遍历二叉树，得到的结果将从小到大有序。手工判别二叉排序树的方法之一。</p>

<p>（例）</p></li>
<li><p>查找</p>

<p>思路：</p>

<ol>
<li>若二叉树为空，则找不到</li>
<li>先与根比较，相等则找到，否则若小于根则在左子树上继续查找，否则在右子树上继续查找。</li>
</ol>

<p>递归算法：</p>

<pre><code>BstTree BstSearch(BstTree bst, DataType x){
    if (bst==NULL)
        return NULL;
    else if (bst-&gt;data==x)
        return bst;
    else if (x&lt;bst-&gt;data)
        return BstSearch(bst-&gt;lchild, x);
    else
        return BstSearch(bst-&gt;rchild, x);

}
</code></pre>

<p>非递归算法：</p>

<pre><code>BstTree BstSearch(BstTree bst, DataType x){
    p = bst;
    while(p){
        if (p-&gt;data==x)
            return p;
        else if (x&lt;p-&gt;data)
            p = p-&gt;lchild;
        else
            p = p-&gt;rchild;
    }
    return NULL;//没有找到
}   
</code></pre></li>
<li><p>插入</p>

<p>思路：先查找，若找不到则插入结点作为最后访问的叶子结点的孩子。新插入的结点总是叶子。  </p></li>
<li><p>建立</p>

<p>经过一系列插入操作可以建立二叉排序树。</p>

<p>给定关键词序列，建立二叉排序树。方法：</p>

<ol>
<li>开始二叉树为空</li>
<li>对每一个关键字，先进行查找，如果已存在，则不作任何处理，否则插入。</li>
</ol>

<p>一句话：“从空树开始，每次插入一个关键字”。</p>

<p>（例）</p></li>
<li><p>删除</p>

<ol>
<li>叶子：直接删除即可。（图）</li>
<li>左子树或右子树为空：“移花接木”：将左子树或右子树接到双亲上。（图）</li>
<li>左右子树都不空：“偷梁换柱”：借左子树上最大的结点替换被删除的结点，然后删除左子树最大结点，（或者借用右子树上最小结点然后删除之亦可）（图）</li>
</ol></li>
<li><p>分析</p>

<p>判定树和二叉排序树相同。结点的层次等于查找时比较关键字的个数。</p>

<p>（图）</p>

<p>若按照关键字有序的顺序插入结点建立二叉排序树，将得到一棵单支树，对其进行查找也退化为顺序查找，平均查找长度为\(\frac{1+n}{2}\)。一般的，如果在任一关键字k之后插入二叉排序树的关键字都大于或都小于k，则该二叉排序树是单分支的，深度是n，查找效率和顺序查找相同。</p></li>
</ol>

<h4 id="toc_91">6. 平衡二叉树</h4>

<ol>
<li><p>平衡因子和平衡二叉树（AVL）</p>

<p>平衡因子：左子树深度-右子树深度。平衡二叉树中各个结点的平衡因子只能是0、1、-1.</p></li>
<li><p>构造平衡二叉排序树</p>

<p>思路：按照建立二叉排序树的方法逐个插入结点，失去平衡时作调整。</p>

<p>失去平衡时的调整方法：</p>

<ol>
<li>确定三个代表性结点。（A是失去平衡的最小子树的根；B是A的孩子；C是B的孩子，也是新插入结点的子树）。关键是找到失去平衡的最小子树。</li>
<li>根据三个代表性结点的相对位置（C和A的相对位置）判断是哪种类型（LL、LR、RL、RR）</li>
<li>平衡化。“先摆好三个代表性结点（居中者为根），再接好其余子树（根据大小）”</li>
</ol>

<p>（图）*（例）</p></li>
<li><p>分析</p>

<ol>
<li>查找（同二叉排序树）</li>
<li><p>平均查找长度ASL</p>

<p>结论：平均查找性能O(log n)</p>

<p>为求得n个结点的平衡二叉树的最大高度，考虑高度为h的平衡二叉树的最少结点数。</p>

<p>\(N_{h}=\lbrace{0,h=0\\1,}\)</p>

<p>部分结果如下，\(F_h\)表示斐波那契数列第h项。</p>

<p>（表）</p>

<p>观察可以得出\(N_h=F_{h+2}-1,h\geq0\)，解得\(h=log_\varphi(\sqrt{5}(n+1))-2\approx1.44log(n+1)-0.328\).其中\(\varphi=(\frac{\sqrt{5}+1}{2})\)。</p></li>
<li><p>时间复杂度 </p>

<p>一次查找经过根到某结点的路径，所以查找的时间复杂度是O(logn)</p></li>
</ol></li>
</ol>

<h4 id="toc_92">7. B-树与B+树</h4>

<ol>
<li><p>B-树：一棵m阶B-树，或为空树，或满足：</p>

<ol>
<li>每个结点至多有m棵子树；</li>
<li>若根结点不是叶子，则至少有两棵子树；</li>
<li>除根之外的所有非终端结点至少有\(\lceil \frac{m}{2} \rceil\)棵子树；</li>
<li>所有非终端结点包含n个关键字和n+1棵子树：\((n, A_0,K_1,A_1,\dots,K_n,A_n)\)，其中关键字满足\(A_0 &lt;K_1 &lt;A_1 &lt;\dots &lt;K_n &lt;A_n\)，关键字的个数\(\lceil \frac{m}{2} \rceil-1 \leq n\leq m-1\)。</li>
<li>所有叶子在同一层，不含信息，表示查找失败。</li>
</ol></li>
<li><p>B+树</p>

<p>B+树和B-树的差异：n棵子树的结点中含有n个关键字；所有叶子结点中包含了全部关键字，且按大小顺序排列；所有非终端结点都是索引。</p>

<p>对B+树既可以进行顺序查找又可以进行随机查找。</p></li>
</ol>

<h4 id="toc_93">8. 键树</h4>

<p>又叫数字查找树。常见的两种存储结构：孩子兄弟链表，多重链表。</p>

<h4 id="toc_94">9. 哈希表</h4>

<ol>
<li><p>哈希表（散列表、杂凑表）</p>

<p>根据设定的哈希函数和处理冲突的方法，将一组关键字映像到一个有限的连续的地址集上，并以关键字在地址集中的象作为记录在表中的存储位置，这种表称为哈希表，又叫做散列表、杂凑表。</p></li>
<li><p>哈希函数</p>

<p>常用除留余数法：<code>H(key)=key MOD p</code></p></li>
<li><p>冲突</p>

<p>什么是冲突？\(H(key_1)=H(key_2)\)，且\(key_1\neq key_2\)，称冲突。</p>

<p>处理冲突的方法：当\(H(key)\)处已有记录，出现冲突，如何处理？</p>

<ol>
<li><p>开放定址法</p>

<p>试用\(H(key)\oplus d_i\)，常见以下三种：</p>

<ol>
<li>线形探测再散列：试用\(H(key)\oplus 1, H(key)\oplus 2,\dots\)</li>
<li>二次探测再散列：试用\(H(key)\oplus 1^2, H(key)\oplus -1^2, H(key)\oplus 2^2, H(key)\oplus -2^2,\dots\)</li>
<li>伪随机探测再散列：试用\(H(key)\oplus f(1), H(key)\oplus f(2),\dots\)</li>
</ol></li>
<li><p>再哈希法</p>

<p>\(H_1(key)\)冲突，试用\(H_2(key), H_3(key), \dots\)</p></li>
<li><p>链地址法</p>

<p>发生冲突的记录链成单链表。</p></li>
<li><p>建立公共溢出区</p>

<p>所有冲突记录存储溢出区。</p></li>
</ol></li>
<li><p>装填因子</p>

<p>\(\alpha=\frac{n}{m}\)，n个记录，m个地址空间。哈希表的平均查找长度与记录个数n不直接相关，而是取决于装填因子和处理冲突的方法。</p></li>
<li><p>举例</p>

<p>（例）</p></li>
</ol>

<h2 id="toc_95">第九章 排序</h2>

<h3 id="toc_96">一、考纲要求</h3>

<ol>
<li>掌握各种排序算法，包括插入类、交换类、选择类、归并类排序及基数排序；</li>
<li>能够对各种排序方法进行比较分析，如稳定性、时间和空间性能等，了解各种排序方法的特点和不同并灵活应用；</li>
<li>理解外部排序的主要思想和过程。</li>
</ol>

<h3 id="toc_97">二、基本知识</h3>

<h4 id="toc_98">1. 排序的有关概念</h4>

<p><strong>排序：</strong>按关键字大小顺序排列数据。</p>

<p>排序方法：内部排序、外部排序；简单的排序方法\(O(n^2)\)、先进的排序方法\(O(nlogn)\)、基数排序\(O(dn)\)；插入排序、交换排序、选择排序、归并排序、计数排序。</p>

<p><strong>排序方法的稳定性：</strong>取决于该方法采取的策略，不是由一次具体的排序结果决定的。但是通过列举不稳定的排序实例可以说明该排序算法的不稳定性。</p>

<h4 id="toc_99">2. 直接插入排序</h4>

<ol>
<li><p>思路</p>

<p>将待排序记录插入已排好的记录中，不断扩大有序序列。一句话：将待排序记录插入有序序列，重复n-1次。</p>

<p>（例）</p></li>
<li><p>分析</p>

<table>
<thead>
<tr>
<th></th>
<th>比较</th>
<th>移动</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>记录顺序有序时</td>
<td>n-1</td>
<td>0</td>
<td>最好</td>
</tr>
<tr>
<td>记录逆序有序时</td>
<td>\(\frac{(n+2)(n-1)}{2}\)</td>
<td>\(\frac{(n+4)(n-1)}{2}\)</td>
<td>最坏</td>
</tr>
</tbody>
</table></li>
</ol>

<h4 id="toc_100">3. 折半插入排序</h4>

<ol>
<li><p>思路</p>

<p>在直接插入排序中，查找插入位置时采用折半查找的方法。</p></li>
<li><p>程序</p>

<pre><code>void BinInsertSort(T a[], int n){
    for (int i = 0; i &lt; n; ++i)
    {
        // 在a[0...i-1]中折半查找插入位置使a[high]&lt;=a[i]&lt;a[high+1...i-1]
        low = 0;
        high = i-1;
        while(low&lt;=high){
            m = (low+high)/2;
            if (a[u]&lt;a[m])
                high = m-1;
            else
                low = m+1;
        }
        // 向后移动元素a[high+1...i-1]，在a[high+1]处插入a[i]
        x=a[i];
        for (int j = i-1; j &gt; high; ++j)
        {
            a[j+1] = a[j];          
        }
        a[high+1] = x;// 完成插入
    }
}
</code></pre></li>
<li><p>分析</p>

<p>时间复杂度\(O(n^2)\)，比直接插入排序减少了比较次数，折半插入排序是稳定的排序算法。</p></li>
</ol>

<h4 id="toc_101">4. 希尔排序（缩小增量排序）</h4>

<ol>
<li><p>思路</p>

<p>先将待排序分割成若干个子序列，分别进行直接插入排序，基本有序后再对整个序列进行直接插入排序。</p>

<p>步骤：</p>

<ol>
<li>分成子序列（按照增量dk）；</li>
<li>对子序列排序（直接插入排序）；</li>
<li>缩小增量，重复以上步骤，直到增量dk=1.</li>
</ol>

<p>增量序列中最后一个增量一定是1，入：...,9,5,3,2,1和...13,4,1。如没有明确说明增量序列可以选择...,3,2,1或...,5,3,2,1</p>

<p>（例）</p></li>
<li><p>程序</p>

<pre><code>void ShellSort(T a[], int n){
    dk = n/2;
    while(dk &gt;= 1){
        // 一趟希尔排序，对dk个序列分别进行插入排序
        for (int i = dk; i &lt; n; ++i)
        {
            x = a[i];
            for (int j = i-dk; j &gt;= 0 &amp;&amp; x &lt; a[j]; j-=dk)
                a[j+dk] = a[j];
            a[j+dk] = x;
        }
        // 缩小增量
        dk = dk/2;
    }
}
</code></pre></li>
</ol>

<h4 id="toc_102">5. 冒泡排序</h4>

<ol>
<li><p>思路</p>

<p>一句话：“依次比较相邻元素，‘逆序’则交换，重复n-1次”。</p></li>
<li><p>程序</p>

<p>请参考BubbleSort</p></li>
<li><p>分析</p>

<p>比较和交换总是发生在相邻元素之间，是稳定的排序算法。时间复杂度为\(O(n^2)\)。</p></li>
</ol>

<h4 id="toc_103">6. 快速排序</h4>

<ol>
<li><p>思路</p>

<p>一趟排序把记录分割成独立的两部分，一部分关键字均比另一部分小，然后再分别对两部分快排。</p>

<p>（例）</p></li>
<li><p>程序</p>

<pre><code>void QuickSort(T a[], int low, int high){
    if(low &lt; high){
        // 划分
        pivot = a[low];
        i = low;
        j = high;
        while(i &lt; j){
            while(i &lt; j &amp;&amp; a[j] &gt;= pivot)
                j--;
            a[i] = a[j];
            while(i &lt; j &amp;&amp; a[i] &lt;= pivot)
                i++;
            a[j]=a[i];

        }
        a[i] = pivot;
        // 对子序列快排
        QuickSort(a, low, i-1);
        QuickSort(a, i+1, high);
    }   
}
</code></pre></li>
<li><p>分析</p></li>
</ol>

<p>平均情况下，时间复杂度\(O(nlogn)\)。记录本来有序时为最坏情况，时间复杂度为\(O(n^2)\)。空间复杂度（考虑递归调用的最大深度）在平均情况下为\(O(logn)\)，在最坏情况下为\(O(n)\)。快速排序是不稳定的。</p>

<h4 id="toc_104">7. 简单选择排序</h4>

<ol>
<li><p>思路</p>

<p>第i趟排序过程是在剩余的待排记录中选一个最小（大）的，放在第i个位置。一句话，“在待排记录中选取最小的，交换到合适位置，重复n-1次”。</p>

<p>（例）</p></li>
<li><p>程序</p>

<pre><code>void SelectionSort(T a[], int n){
    for (int i = 0; i &lt; n-1; ++i)
    {
        k = i;
        for (int j = i+1; j &lt; n; ++j)
        {
            if(a[j] &lt; a[k])
                k = j; // 最小记录
        }
        if (k != i)
        {
            int temp;
            temp = a[i];
            a[i] = a[k];
            a[k] = temp;
        }
    }
}
</code></pre></li>
<li><p>分析</p></li>
</ol>

<h4 id="toc_105">8. 堆排序</h4>

<ol>
<li><p>堆及其特点</p>

<p>堆、小顶堆、大顶堆</p>

<p>序列\({K_1,K_2,\dots,K_n}\)满足\(K_i\leq K_{2i},K_i\leq K_{2i+1}\)，称为小顶堆；若满足\(K_i\geq K_{2i},K_i\geq K_{2i+1}\)，称为大顶堆，其中\(i=1,2,\dots,\frac{n}{2}\)</p>

<p>特点：小顶堆的堆顶（第一个元素）为最小元素，大顶堆的堆顶为最大元素。</p></li>
<li><p>判断序列是否构成堆</p>

<p>方法：用\(K_i\)作为编号为i的结点，画一棵完全二叉树，比较双亲和孩子容易判断是否构成堆。</p>

<p>（例）</p></li>
<li><p>建立堆</p>

<p>一句话，“‘小堆’变‘大堆’，从\(\lfloor \frac{n}{2} \rfloor \)变到1”。第\(\lfloor \frac{n}{2} \rfloor \)个是最后一个分支结点。</p>

<p>（例）</p></li>
<li><p>堆排序</p>

<p>思路：（图）</p>

<p>（例）</p></li>
</ol>

<h4 id="toc_106">9. 归并排序</h4>

<ol>
<li><p>思路</p>

<p>归并：两个或多个有序表合并成一个有序表。</p></li>
<li><p>程序</p>

<p>归并排序：</p>

<pre><code>void MergeSort(T a[], int low, int high){
    if (low &gt;= high)
        return ;
    else
    {
        mid = (low + high)/2;
        MergeSort(a, low, mid);
        MergeSort(a, mid+1, high);
        Merge(a, low, mid, high);
    }
}
</code></pre>

<p>自顶向上的归并排序：</p>

<pre><code>void MergeSort(T a[], int n){
    t = 1;
    while(t &lt; n){
        s = t;
        t = s*2;
        for (int i = 0; i+t &lt; n; i+=t)
            Merge(a, i, i+s-1, i+t-1);
        if(i+s &lt; n)
            Merge(a, i, i+s-1, n-1);
    }
}
</code></pre>

<p>附：Merge(),将有序序列a[low..mid]和a[mid+1...high]归并到a[low...high]。</p>

<pre><code>void Merge(T a[], int low, int mid, int high){
    // 归并到b[]
    i = low;
    j = mid + 1;
    k = low;
    while(i &lt;= mid &amp;&amp; j &lt;= high){
        if (a[i] &lt;= a[j])
        {
            b[k] = a[i];
            i++;
        }
        else
        {
            b[k]=a[j];
            j++;
        }
        k++;
    }
    // 归并剩余元素
    while(i &lt;= mid)
        b[k++] = a[i++];
    while(j &lt;= high)
        b[k++] = a[j++];
    //从b[]复制回a[]
    a[low...high] = b[low...high];
}
</code></pre></li>
<li><p>分析</p>

<p>时间复杂度\(O(nlogn)\)。需要空间多，空间复杂度\(O(n)\)。归并排序是稳定的排序。</p></li>
</ol>

<h4 id="toc_107">10. 基数排序</h4>

<ol>
<li><p>思路</p>

<ol>
<li><p>多关键字排序</p>

<p>最高位有限（马上到！）、最低位有限（LSD）</p></li>
<li><p>链式基数排序</p>

<p>链式基数排序采用“分配”和“收集”策略。</p>

<p>（例）</p></li>
</ol></li>
<li><p>分析</p>

<p>对n个数据进行基数排序，每个数据基数为rd，有d位数字。那么，一趟分配和收集用时n+rd（分配用n，收集用rd），共需d趟，总的时间复杂度为\(O(d(n+rd))\)。</p></li>
</ol>

<h4 id="toc_108">11. 各种排序比较</h4>

<p>（表）</p>

<h4 id="toc_109">12. 外部排序</h4>

<ol>
<li>外部排序三种方式</li>
<li>外部排序主要思想与过程</li>
<li>构建最大败子树 </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建网站咯~]]></title>
    <link href="https://zning.me/GD/14668285689054.html"/>
    <updated>2016-06-25T12:22:48+08:00</updated>
    <id>https://zning.me/GD/14668285689054.html</id>
    <content type="html"><![CDATA[
<p>嘿嘿嘿</p>

]]></content>
  </entry>
  
</feed>
